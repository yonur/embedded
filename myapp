//*****************************************************************************
// HTTP server.
// Adam Dunkels <adam@dunkels.com>
//
// Copyright (c) 2001, Adam Dunkels.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote
//    products derived from this software without specific prior
//    written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// This file is part of the uIP TCP/IP stack.
//
//*****************************************************************************

#include "uip.h"
#include "myapp.h"

//*****************************************************************************
//
// Macro for easy access to buffer data
//
//*****************************************************************************
#define BUF_APPDATA ((u8_t *)uip_appdata)

//*****************************************************************************
//
// Definitions of HTTP Server States
//
//*****************************************************************************
#define HTTP_NOGET      0
#define HTTP_FILE       1
#define HTTP_TEXT       2
#define HTTP_FUNC       3
#define HTTP_END        4

//*****************************************************************************
//
// Global for keeping up with web server state.
//
//*****************************************************************************
struct my_state *hs;

void my_init(void)
{
    //
    // Listen to port 6340.
    //
    uip_listen(HTONS(6340));
}

void my_appcall(void)
{
	switch(uip_conn->lport)
	    {
	        //
	        // This is the web server:
	        //
	        case HTONS(6340):
	        {
	            //
	            // Pick out the application state from the uip_conn structure.
	            //
	            hs = (struct my_state *)&(uip_conn->appstate);

	            //
	            // We use the uip_ test functions to deduce why we were
	            // called. If uip_connected() is non-zero, we were called
	            // because a remote host has connected to us. If
	            // uip_newdata() is non-zero, we were called because the
	            // remote host has sent us new data, and if uip_acked() is
	            // non-zero, the remote host has acknowledged the data we
	            // previously sent to it.
	            if(uip_connected())
	            {
	                //
	                // Since we have just been connected with the remote host, we
	                // reset the state for this connection. The ->count variable
	                // contains the amount of data that is yet to be sent to the
	                // remote host, and the ->state is set to HTTP_NOGET to signal
	                // that we haven't received any HTTP GET request for this
	                // connection yet.
	                //
	                hs->state = HTTP_NOGET;
	                hs->count = 0;
	                hs->bufcount = 0;
	                return;
	            }
	            else if(uip_poll())
	            {
	                //
	                // If we are polled ten times, we abort the connection. This is
	                // because we don't want connections lingering indefinately in
	                // the system.
	                //
	                if(hs->count++ >= 0)
	                {
	                	uip_send("Poll ",5);
	                }
	                return;
	            }
	            else if(uip_newdata() && hs->state == HTTP_NOGET)
	            {
	                //
	                // This is the first data we receive, and it should contain a
	                // GET.
	                //
	                // Check for GET.
	                //

	                //
	                // Check to see what we should send.
	                //
	                if((BUF_APPDATA[0] == 'a') &&
	                   (BUF_APPDATA[1] == 'b'))
	                {
	                    //
	                    // Send buffer 1
	                    //
	                    uip_send("Nbr\n",
	                            4);
	                    hs->state = HTTP_TEXT;
	                }
	                else
	                {
	                    uip_send("Gelmedi mesajin\n",
	                            16);
	                    hs->bufcount = 3;
	                }
	            }
	            else if(uip_acked() && (hs->state == HTTP_TEXT))
	            {

	                	if((BUF_APPDATA[0] == 'a') && (BUF_APPDATA[1] == 'b'))
	                    {
	                		//
	                		// Send buffer 1
	                		//
	                		uip_send("Nbr gene\n",9);
	                		SysCtlDelay(1000);
	                	}else
	                	{
		                    uip_send("Merhaba ",
		                            7);


		                    uip_send("Televole ",
		                            9);


		                	uip_send("Turkiye ",8);
		                    //uip_close();
	                	}



	            }
	            //
	            // Finally, return to uIP. Our outgoing packet will soon be on its
	            // way...
	            //
	            return;
	        }

	        default:
	        {
	            //
	            // Should never happen.
	            //
	            uip_abort();
	            break;
	        }
	    }
}
