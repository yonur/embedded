//**********MyApp Header*********************************************************//
#ifndef __MYAPP_H__
#define __MYAPP_H__

//*****************************************************************************
//
// Web Server Application Entry Points.
//
//*****************************************************************************
void my_appcall(void);
void my_init(void);

//*****************************************************************************
//
// Web Server Application State Variable Definition.
//
//*****************************************************************************
struct my_state
{
    u8_t state; 
    u16_t count;
    u16_t bufcount;
};

#endif // __MYAPP_H__
//*****************************************************************************//


//**********MyApp c file****************************************************//

#include "uip.h"
#include "myapp.h"

//*****************************************************************************
//
// Macro for easy access to buffer data
//
//*****************************************************************************
#define BUF_APPDATA ((u8_t *)uip_appdata)
#define SEND_DATA   ((u8_t *)uip_appdata)
//*****************************************************************************
//
// Definitions of HTTP Server States
//
//*****************************************************************************
#define CONNECTED        0
#define ETH_COR	         1
#define TEST_START       3
#define TEST_CONT		 4
#define END              5

//*****************************************************************************
//
// Global for keeping up with web server state.
//
//*****************************************************************************
struct my_state *hs;

void my_init(void)
{
    //
    // Listen to port 6340.
    //
    uip_listen(HTONS(6340));
}

void my_appcall(void)
{
	switch(uip_conn->lport)
	    {
	        //
	        // This is the web server:
	        //
	        case HTONS(6340):
	        {
	            //
	            // Pick out the application state from the uip_conn structure.
	            //
	            hs = (struct my_state *)&(uip_conn->appstate);

	            //
	            // We use the uip_ test functions to deduce why we were
	            // called. If uip_connected() is non-zero, we were called
	            // because a remote host has connected to us. If
	            // uip_newdata() is non-zero, we were called because the
	            // remote host has sent us new data, and if uip_acked() is
	            // non-zero, the remote host has acknowledged the data we
	            // previously sent to it.
	            if(uip_connected())
	            {
	                //
	                // Since we have just been connected with the remote host, we
	                // reset the state for this connection. The ->count variable
	                // contains the amount of data that is yet to be sent to the
	                // remote host, and the ->state is set to HTTP_NOGET to signal
	                // that we haven't received any HTTP GET request for this
	                // connection yet.
	                //
	                hs->state = CONNECTED;
	                return;
	            }
	            else if(uip_poll() && hs->state == TEST_START)
	            {
	                //
	                // If we are polled ten times, we abort the connection. This is
	                // because we don't want connections lingering indefinately in
	                // the system.
	                //

	                	uip_send(SEND_DATA,122);

	                	//Eger test stop biti gelirse testi bitir.
	                	if(hs->state == END)
	                		uip_close();
	                return;
	            }
	            else if(uip_newdata() && hs->state == CONNECTED)
	            {
	                //
	                // Ilk data alindi
	                //
	                // Ilk bit 1 olana kadar test status gonderilmez
	                //
	                //
	                // SSIB' tan Ethernet command order geldi mi? Kontrol edilir.
	                //
	                if((BUF_APPDATA[0] == 1))
	                {
	                    //
	                    // Test Status biti birlenir ve ilk veri SSIB' e gonderilir.
	                    //
	                	SEND_DATA[1] = 1;
	                    uip_send(SEND_DATA,122);
	                    hs->state = ETH_COR;
	                }
	            }
	            else if(uip_acked() && (hs->state == ETH_COR))
	            {

	            		// Init CLT geldi mi kontrol edilir. Oyle ise test basla biti birlenir ve test baslatilir.
	                	if((BUF_APPDATA[2] == 1) && hs->bufcount == 0)
	                    {
	                		hs->state = TEST_START;
	                		SEND_DATA[3] = 1;
	                		uip_send(SEND_DATA,122);
	                		hs->bufcount++;
	                	}
	                	TimerEnable(TIMER0_BASE,TIMER_BOTH);
	                	while(TimerValueGet(TIMER0_BASE)){
	                		SEND_DATA[4] = GPIOPinRead(GPIO_PORTC_BASE, GPIO_PIN_4) >> 4;
	                		uip_send(SEND_SATA, 122);
	                	}
	                	//2 saniye bekleme
	                	TimerEnable(TIMER0_BASE,TIMER_BOTH);
	                	while(TimerValueGet(TIMER0_BASE)){
	                		SEND_DATA[5] = GPIOPinWrite(GPIO_PORTC_BASE, GPIO_PIN_5) >> 5;
	                		uip_send(SEND_DATA,122);
	                	}
	            }
	            //
	            // Finally, return to uIP. Our outgoing packet will soon be on its
	            // way...
	            //
	            return;
	        }

	        default:
	        {
	            //
	            // Should never happen.
	            //
	            uip_abort();
	            break;
	        }
	    }
}


//TCP header(20) ne kadar ? Link level header(14) ne kadar?
