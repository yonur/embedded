#include <stdint.h>
#include <stdbool.h>
#include "inc/tm4c123gh6pm.h"
unsigned long ADCdata;
unsigned long Distance;
char String[9];
int flag = 0;
void ADC0_Init(void) // initialize ADC0, chan 1, sequencer 3, software start
{
	volatile uint32_t delay;
	
	SYSCTL_RCGC2_R |= 0x10; //PortE clock
	delay = SYSCTL_RCGC2_R;
	GPIO_PORTE_DIR_R &= ~0x04; //PE2 input
	GPIO_PORTE_DEN_R &= ~0x04; //disable digital I/O on PE2
	GPIO_PORTE_AFSEL_R |= 0x04; //enable alternate func of PE2
	GPIO_PORTE_AMSEL_R |= 0x04; //enable analog functionality of PE2
	SYSCTL_RCGC0_R |= 0x10000; //activate ADC0
	delay = SYSCTL_RCGC0_R;
	SYSCTL_RCGC0_R &= ~0x0300; //conf for 125k 
	ADC0_SSPRI_R = 0x0123; // sequencer3 is highest priority
	ADC0_ACTSS_R &= ~0x08; //disable sample sequencer3
	ADC0_EMUX_R &= ~0xF000; //seq3 is software sequencer
	ADC0_SSMUX3_R = (ADC0_SSMUX3_R & 0xFFFFFFF0)+1; //channel ain1 (PE2)
	ADC0_SSCTL3_R = 0x06; //no TS0 D0, yes IE0 END0
	ADC0_ACTSS_R |= 0x08; //enable sample sequencer3
}

void UART_Init(void)
{
	SYSCTL_RCGC1_R |= 0x02; //activate uart1
	SYSCTL_RCGC2_R |= 0x04; //activate portc
	UART1_CTL_R &= ~0x01; //disable UART
	UART1_IBRD_R = 43;
	UART1_FBRD_R = 26; //baud rate 115200
	UART1_CTL_R |= 0x01; //enable uart1
	GPIO_PORTC_AFSEL_R |= 0x30; //enable alt funct on PC5-4
	GPIO_PORTC_DEN_R |= 0x30; //configure PC5-4 as UART1
	GPIO_PORTC_PCTL_R = (GPIO_PORTC_PCTL_R&0xFF00FFFF)+0x00220000;
	GPIO_PORTC_AMSEL_R &= ~0x30; //disable analog on PC5-4
}

unsigned char UART_InChar(void){
  while((UART1_FR_R&UART_FR_RXFE) != 0);
  return((unsigned char)(UART1_DR_R&0xFF));
}
//------------UART_OutChar------------
// Output 8-bit to serial port
// Input: letter is an 8-bit ASCII character to be transferred
// Output: none
void UART_OutChar(unsigned char data){
  while((UART1_FR_R&UART_FR_TXFF) != 0);
  UART1_DR_R = data;
}


//------------UART_OutString------------
// Output String (NULL termination)
// Input: pointer to a NULL-terminated string to be transferred
// Output: none
void UART_OutString(char *pt){
  while(*pt){
    UART_OutChar(*pt);
    pt++;
  }
}


void UART_ConvertDistance(unsigned long n){
// as part of Lab 11 implement this function
  if(n < 10) {
		String[0] = '0';
		String[2] = '0';
		String[3] = '0';
		String[4] = n + '0';
	} else if (n < 100) {
		String[0] = '0';
		String[2] = '0';
		String[3] = n/10 + '0';
		String[4] = (n%10) + '0';
	} else if (n < 1000) {
		String[0] = '0';
		String[2] = n/100 + '0';
		String[3] = (n%100)/10 + '0';
		String[4] = (n%10) + '0';
	} else if (n < 10000) {
		String[0] = n/1000 + '0';
		String[2] = (n%1000)/100 + '0';
		String[3] = (n%100)/10 + '0';
		String[4] = (n%10) + '0';
	} else {
		String[0] = '*';
		String[2] = '*';
		String[3] = '*';
		String[4] = '*';
	}
	String[1] = '.';
	String[5] = ' ';
	String[6] = 'c';
	String[7] = 'm';
	String[8] = '\0';
}
unsigned long Convert(void)
{
	unsigned long result;
	result = ((466*ADCdata)>>10) + 144;
	return result;
}
void SysTickInit(unsigned long period)
{
	NVIC_ST_CTRL_R = 0; //disable systick during setup
	NVIC_ST_RELOAD_R = period - 1; //reload value
	NVIC_ST_CURRENT_R = 0; //any write to current clears it
	NVIC_SYS_PRI3_R = (NVIC_SYS_PRI3_R & 0x00FFFFFF) | 0x40000000;
	NVIC_ST_CTRL_R = 0x07; //enable SysTick with core clock
}


unsigned long ADC0_In(void)
{
	unsigned long result;

	ADC0_PSSI_R = 0x0008;            // 1) initiate SS3
	while((ADC0_RIS_R&0x08)==0){};   // 2) wait for conversion done
	result = ADC0_SSFIFO3_R&0xFFF;   // 3) read result
	ADC0_ISC_R = 0x0008;             // 4) acknowledge completion
	
	//flag = 0;
	return result;
}
void toggle(void)
{
	GPIO_PORTF_DATA_R ^= 0x02;
}
void SysTick_Handler(void)
{
	toggle();
	toggle();
	ADCdata = ADC0_In();
	Distance = Convert();

	flag = 1;
	
	toggle();
}


void EnableInterrupts(void);

int main(void)
{
	SYSCTL_RCGC2_R |= 0x00000020; // activate port F
  //Counts = 0;
  GPIO_PORTF_DIR_R |= 0x02;   // make PF1 output (PF1 built-in LED)
  GPIO_PORTF_AFSEL_R &= ~0x02;// disable alt funct on PF1
  GPIO_PORTF_DEN_R |= 0x02;   // enable digital I/O on PF1
  GPIO_PORTF_PCTL_R = (GPIO_PORTF_PCTL_R&0xFFFFFF0F)+0x00000000;
  GPIO_PORTF_AMSEL_R = 0;     // disable analog functionality on PF
	ADC0_Init();
	UART_Init();
	SysTickInit(400000);
	EnableInterrupts();

	while(1)
	{
		flag = 0;
		while(!flag){}
		UART_ConvertDistance(Distance);
		UART_OutString(String);
		UART_OutChar('\n');
	}
}
;******************************************************************************
;
; Some code in the normal code section for initializing the heap and stack.
;
;******************************************************************************
        AREA    |.text|, CODE, READONLY

;******************************************************************************
;
; Useful functions.
;
;******************************************************************************
        EXPORT  DisableInterrupts
        EXPORT  EnableInterrupts
        EXPORT  StartCritical
        EXPORT  EndCritical
        EXPORT  WaitForInterrupt

;*********** DisableInterrupts ***************
; disable interrupts
; inputs:  none
; outputs: none
DisableInterrupts
        CPSID  I
        BX     LR

;*********** EnableInterrupts ***************
; disable interrupts
; inputs:  none
; outputs: none
EnableInterrupts
        CPSIE  I
        BX     LR

;*********** StartCritical ************************
; make a copy of previous I bit, disable interrupts
; inputs:  none
; outputs: previous I bit
StartCritical
        MRS    R0, PRIMASK  ; save old status
        CPSID  I            ; mask all (except faults)
        BX     LR

;*********** EndCritical ************************
; using the copy of previous I bit, restore I bit to previous value
; inputs:  previous I bit
; outputs: none
EndCritical
        MSR    PRIMASK, R0
        BX     LR

;*********** WaitForInterrupt ************************
; go to low power mode while waiting for the next interrupt
; inputs:  none
; outputs: none
WaitForInterrupt
        WFI
        BX     LR
