http://forum.43oh.com/topic/9487-my-time-with-freertos-on-the-tm4c/

/* Standard includes. */
#include <stdio.h>
#include <stdlib.h>
/* FreeRTOS kernel includes. */
#include "FreeRTOS.h"
#include "task.h"
#include <queue.h>
#include <timers.h>
#include <math.h>
/* This demo uses heap_5.c, and these constants define the sizes of the regions
that make up the total heap. This is only done to provide an example of heap_5
being used as this demo could easily create one large heap region instead of
multiple smaller heap regions - in which case heap_4.c would be the more
appropriate choice. */
#define mainREGION_1_SIZE 3001
#define mainREGION_2_SIZE 18105
#define mainREGION_3_SIZE 1107
#define TASK1_STACK_SIZE 1000
#define TASK2_STACK_SIZE 100
#define TASK1_PRIORITY 3
#define TASK2_PRIORITY 1
/*
* This demo uses heap_5.c, so start by defining some heap regions. This is
* only done to provide an example as this demo could easily create one large
* heap region instead of multiple smaller heap regions - in which case heap_4.c
* would be the more appropriate choice. No initialisation is required when
* heap_4.c is used.
*/
static void prvInitialiseHeap(void);
/*
* Prototypes for the standard FreeRTOS callback/hook functions implemented
* within this file.
*/
void vApplicationMallocFailedHook(void);
void vApplicationIdleHook(void);
void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName);
void vApplicationTickHook(void);
/*
* Writes trace data to a disk file when the trace recording is stopped.
* This function will simply overwrite any trace files that already exist.
*/
static void prvSaveTraceFile(void);
/* The user trace event posted to the trace recording on each tick interrupt.
Note tick events will not appear in the trace recording with regular period
because this project runs in a Windows simulator, and does not therefore
exhibit deterministic behaviour. */
traceLabel xTickTraceUserEvent;
static portBASE_TYPE xTraceRunning = pdTRUE;
/*-----------------------------------------------------------*/
void vTask1Code();
void vTask2Code();
const char *nameTask1 = "Task1\n";
const char *nameTask2 = "Task2\n";
int main(void)
{
TaskHandle_t x1Handle;
TaskHandle_t x2Handle;
/* This demo uses heap_5.c, so start by defining some heap regions. This
is only done to provide an example as this demo could easily create one
large heap region instead of multiple smaller heap regions */
prvInitialiseHeap();
/* Initialise the trace recorder and create the label used to post user
events to the trace recording on each tick interrupt. */
vTraceInitTraceData();
xTickTraceUserEvent = xTraceOpenLabel("tick");
if (xTaskCreate(
vTask1Code,
"Number1 Task",
TASK1_STACK_SIZE,
(void *)nameTask1,
TASK1_PRIORITY,
&x1Handle
) != pdPASS)
{
}
else
{
vTaskPrioritySet(x1Handle, 3);
}
if (xTaskCreate(
vTask2Code,
"Number1 Task",
TASK2_STACK_SIZE,
(void *)nameTask2,
TASK2_PRIORITY,
&x2Handle
) != pdPASS)
{
}
else
{
vTaskPrioritySet(x2Handle, 1);
}
//This starts the real-time scheduler
vTaskStartScheduler();
for (;; );
return 0;
}
void vTask1Code()
{
const TickType_t xDelay10000ms = pdMS_TO_TICKS(10000);
for (;;)
{
printf(nameTask1);
vTaskDelay(xDelay10000ms);
}
}
void vTask2Code()
{
const TickType_t xDelay1000ms = pdMS_TO_TICKS(1000);
for (;;)
{
printf(nameTask2);
vTaskDelay(xDelay1000ms);
}
}
/*-----------------------------------------------------------*/
void vApplicationMallocFailedHook(void)
{
/* vApplicationMallocFailedHook() will only be called if
configUSE_MALLOC_FAILED_HOOK is set to 1 in FreeRTOSConfig.h. It is a hook
function that will get called if a call to pvPortMalloc() fails.
pvPortMalloc() is called internally by the kernel whenever a task, queue,
timer or semaphore is created. It is also called by various parts of the
demo application. If heap_1.c or heap_2.c are used, then the size of the
heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
to query the size of free heap space that remains (although it does not
provide information on how the remaining heap might be fragmented). */
vAssertCalled(__LINE__, __FILE__);
}
/*-----------------------------------------------------------*/
void vApplicationIdleHook(void)
{
}
/*-----------------------------------------------------------*/
void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName)
{
(void)pcTaskName;
(void)pxTask;
/* Run time stack overflow checking is performed if
configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2. This hook
function is called if a stack overflow is detected. */
vAssertCalled(__LINE__, __FILE__);
}
/*-----------------------------------------------------------*/
void vApplicationTickHook(void)
{
}
/*-----------------------------------------------------------*/
void vAssertCalled(unsigned long ulLine, const char * const pcFileName)
{
static portBASE_TYPE xPrinted = pdFALSE;
volatile uint32_t ulSetToNonZeroInDebuggerToContinue = 0;
/* Parameters are not used. */
(void)ulLine;
(void)pcFileName;
printf("ASSERT! Line %d, file %s\r\n", ulLine, pcFileName);
taskENTER_CRITICAL();
{
/* Stop the trace recording. */
if (xPrinted == pdFALSE)
{
xPrinted = pdTRUE;
if (xTraceRunning == pdTRUE)
{
vTraceStop();
prvSaveTraceFile();
}
}
/* You can step out of this function to debug the assertion by using
the debugger to set ulSetToNonZeroInDebuggerToContinue to a non-zero
value. */
while (ulSetToNonZeroInDebuggerToContinue == 0)
{
__asm { NOP };
__asm { NOP };
}
}
taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/
static void prvSaveTraceFile(void)
{
FILE* pxOutputFile;
pxOutputFile = fopen("Trace.dump", "wb");
if (pxOutputFile != NULL)
{
fwrite(RecorderDataPtr, sizeof(RecorderDataType), 1, pxOutputFile);
fclose(pxOutputFile);
printf("\r\nTrace output saved to Trace.dump\r\n");
}
else
{
printf("\r\nFailed to create trace dump file\r\n");
}
}
/*-----------------------------------------------------------*/
static void prvInitialiseHeap(void)
{
/* This demo uses heap_5.c, so start by defining some heap regions. This is
only done to provide an example as this demo could easily create one large heap
region instead of multiple smaller heap regions - in which case heap_4.c would
be the more appropriate choice. No initialisation is required when heap_4.c is
used. The xHeapRegions structure requires the regions to be defined in order,
so this just creates one big array, then populates the structure with offsets
into the array - with gaps in between and messy alignment just for test
purposes. */
static uint8_t ucHeap[configTOTAL_HEAP_SIZE];
volatile uint32_t ulAdditionalOffset = 19; /* Just to prevent 'condition is always true' warnings in
configASSERT(). */
const HeapRegion_t xHeapRegions[] =
{
/* Start address with dummy offsets Size */
{ ucHeap + 1,
mainREGION_1_SIZE },
{ ucHeap + 15 + mainREGION_1_SIZE,
mainREGION_2_SIZE },
{ ucHeap + 19 + mainREGION_1_SIZE + mainREGION_2_SIZE, mainREGION_3_SIZE },
{ NULL, 0 }
};
/* Sanity check that the sizes and offsets defined actually fit into the
array. */
configASSERT((ulAdditionalOffset + mainREGION_1_SIZE + mainREGION_2_SIZE + mainREGION_3_SIZE)
< configTOTAL_HEAP_SIZE);
vPortDefineHeapRegions(xHeapRegions);
}
/*-----------------------------------------------------------*/
