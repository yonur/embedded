                                                KONFİGÜRASYON
KUSTOMİZASYON:
Bu parametreler birer macro(define)'dur. Tanım değerine göre FreeRTOS farklı konfigürasyona ayarlanabilmektedir.

configUSE_PREEMPTION -> Eğer 1 olarak tanımlanırsa preemptive RTOS scheduler, 0 olarak tanımlanırsa 
cooperative RTOS scheduler kullanılacaktır.

configUSE_PORT_OPTIMISED_TASK_SELECTION -> Bazı FreeRTOS portlarının bir sonraki task'ın çalışması için seçebileceği 2 method bulunmaktadır.
Bu methodlar, generic method ve bu porta özel olan methoddur. 
  Generic Method: 
    - configUSE_PORT_OPTIMISED_TASK_SELECTION 0 olarak ayarlandığında, yada bu porta özel method uygulanmadığında kullanılmaktadır.
    - bütün FreeRTOS portları ile kullanılabilmektedir.
    - bütünüyle C dilinde yazılmıştır, bu durum porta özel methoda göre daha az etkin olmasına neden olmaktadır.
    - erişilebilir priority'lerin sayısının belli bir üst limiti aşmamasına zorlamamaktadır.
  Porta özel method:
    - bütün portlar için erişilebilir değildir.
    - configUSE_PORT_OPTIMISED_TASK_SELECTION 1 olarak ayarlandığında kullanılır.
    - bir yada daha fazla mimariye özel assembly instruction'larına bağlıdır (tipik olarak Count Leading Zeros(CLZ) yada eşdeğer instruction)bundan dolayı özel olarak yazıldığı mimariyle birlikte kullanılabilmektedir.
    - generic method'dan daha etkindir.
    - Tipik olarak maksimum erişilebilir priority sayısı 32 ile sınırlı olmaya zorlanmaktadır.
  
 configUSE_TICKLESS_IDLE -> 'low power tickless mode' ile kullanılması için 1 olarak, yada tick interrupt çalışmayı devamlı çalıştırmak için 0 olarak
 ayarlanır.
 
 configUSE_IDLE_HOOK -> idle hook kullanılacaksa 1 olarak, bir idle hook' u ihmal etmek için ise 0 olarak ayarlanmaktadır.
 
 configUSE_MALLOC_FAILED_HOOK -> kernel, her task, queue yada semafor yaratıldığında heap'ten bir hafıza alanını pvPortMalloc() kullanarak tahsis eder.
 Bu amaçla FreeRTOS'un yüklendiğinde içerisinde bulunan 4 temel hafıza tahsis şeması vardır. heap_1.c, heap_2.c, heap_3.c, heap_4.c ve heap_5.c  kaynak dosyalarında uygulanan
 bu şemalar uygulanmaktadır. configUSE_MALLOC_FAILED_HOOK bu üç şema durumuna uygun olarak uygulanmaktadır.
 malloc() hook fonksiyonu uygulamada hata vermektedir ki bu durumda pvPortMalloc() NULL dönmektedir. NULL yalnızca geri kalan FreeRTOS hafızası 
 başarılı bir yer tahsisi için yetersiz kaldığında geri dönüş değeri olmaktadır.
 Eğer configUSE_MALLOC_FAILED_HOOK 1 olarak ayarlanırsa bir malloc() failed fonksiyonu tanımlanmalıdır. Eğer 0 olarak ayarlanmışsa tanımlanmış olsa bile 
 geri dönmez. Malloc() failed fook fonksiyonunun isimi ve prototip tanımı aşağıda gösterilmiştir.
  void vApplicationMallocFailedHook( void );
 
 configUSE_DAEMON_TASK_STARTUP_HOOK -> Eğer configUSE_TIMERS ve configUSE_DAEMON_TASK_STARTUP_HOOK'nun her ikisi de 1 olarak ayarlanmışsa
 aşağıda gösterildiği şekilde bir isme ve prototipe sahip bir hook fonksiyonu tanımlanmalıdır. Hook fonksiyonu RTOS deamon task(timer servis task' da denilmektedir) 
 ilk defa çalıştığında tam olarak 1 kere çağırılmalıdır. RTOS'un çalışması için gereken herhangi bir uygulamanın ilklendirme hook fonksiyonu içerisine yerleştirilebilmektedir.
  void void vApplicationDaemonTaskStartupHook( void );
  
  configUSE_TICK_HOOK -> 'tick hook'u kullanmak istiyorsak 1 olarak, istemiyorsak 0 olarak ayarlamamız gerekmektedir.
  
  configCPU_CLOCK_HZ -> çevresel birimin kullanması için sürülen dahili(internal) clock'un girilir ki bu değeri genelde dahili CPU clock 
  üretmektedir. Bu değer timer'ları düzgün bir şekilde konfigüre etmek için gerekmektedir.
  
  configTICK_RATE_HZ -> RTOS tick interrupt'ın frekansıdır. 
  tick interrupt zamanı ölçmek için kullanılmaktadır. Bundan dolayı daha yüksek tick frekansına sahip olmak zamanın daha yüksek bir
  çözünürlükle ölçülebilmesini sağlamaktadır.
  
  configMAX_PRIORITIES -> Uygulama task'ı için erişilebilir priority'lerin sayısıdır. Herhangi bir sayıdaki task aynı priority'yi paylaşabilmektedir.
  Coroutine'ler ayrıca önceliklendirileceklerdir (prioritised) - configMAX_CO_ROUTINE_PRIORITIES'i inceleyiniz.
  Herbir erişilebilir priority, RTOS kernel'i içerisindeki RAM'i tüketmektedir ki bundan dolayı sizin uygulamanız tarafından gerçekte istenenden 
  daha yüksek olmamalıdır.
  
  configMINIMAL_STACK_SIZE -> Idle task tarafından kullanılan stack'in boyutudur. Genelde kullanmakta olduğunuz port için olan demo ı-uygulaması 
  ile gelen FreeRTOSConfig.h'im içerisindeki değerden elde edilmemelidir.
  xTaskCreate() ve xTaskCreateStatic() fonksiyonları için olan stack size parametrelerinde olduğu gibi, stack size word cinsinden 
  belirtilmektedir, byte cinsinden değil.
  Stack'teki her bir item 32 bit değerlikli ise, stack size'ın 100 olması 400 byte'lık bir alanı temsil etmektedir (her bir 32 bit'lik stack itemi 4 byte'ı temsil etmektedir).
  
  configMAX_TASK_NAME_LEN -> Task yaratılırken tanımlatıcı ismin müsade edilebilir maksimum uzunluğunu temsil etmektedir. NULL termination byte'ı da içerecek
  şekilde toplam karakter sayısının değeridir.
  
  configUSE_TRACE_FACILITY -> Eğer visualisation ve tracing çalışması ile ek structure member'ların ve fonksiyonların da dahil olması
  isteniyorsa 1 olarak ayarlanmalıdır.
  
  configUSE_STATS_FORMATTING_FUNCTIONS -> Build esnasında vTaskList() ve vTaskGetRunTimeStats() fonksiyonlarının da dahil olması 
  isteniyorsa configUSE_TRACE_FACILITY ve configUSE_STATS_FORMATTING_FUNCTIONS 1 olarak ayarlanmalıdır. Build esnasında ihmal etmek için ise
  0 olarak ayarlanmalıdır.
  
  configUSE_16_BIT_TICKS -> Zaman, RTOS kerneli çalışmaya başladığından beri tick interrupt'ının meydana gelme sayısını temsil eden 'ticks' 
  ile ölçülmektedir.
  configUSE_16_BIT_TICKS'nin 1 olarak ayarlanması TickType_t'nin 16 bit olarak tanımlanmasına, 0 ayarlanması 32 bit olarak tanımlanmasına 
  neden olmaktadır.
  16 bit tip kullanılması 8 bit ve 16 bit mimari için performansı arttırmaktadır fakat zaman periyodunu 65535 tick ile sınırlamaktadır. Bu durumda örneğin
  250 Hz tick frekansı için maksimum gecikme süresi 262 saniyedir fakat 32 bit tip sayıcı kullanılsa 17179869 saniye gecikme verilebilir.
  
  configIDLE_SHOULD_YIELD -> Bu parametre idle priority için task'ların davranışını kontrol eder. Yalnızca etki ettiği durum:
    1- Preemptive scheduler kullanıldığında.
    2- Uygulama idle priority'de çalışan task'lar yarattığında.
  Eğer configUSE_TIME_SLICING 1 olarak ayarlanırsa(yada tanımsızsa) aynı priority'yi paylaşan task'lar zamanı dilimleyeceklerdir. Eğer 
  hiç bir task preempt edilmemişse verilen priority'deki her bir task zamanı eşit zaman diliminde çalışırlar - bu durum gerçekte idle priority'nin
  üstündeki değer için geçerlidir.
  Eğer task'lar idle priority değerinde ise davranışları değişmektedir. Eğer configIDLE_SHOULD_YIELD 1 olaraak set edilmişse idle task başka 
  idle prioty'li task ayarlanmış olsa da hemen çalışır. Bu durum idle task çalıştığı esnada çalışan idle priority'li task'ın diğer diğer idle priority'li
  task'lardan daha az süre almasına sebep olur.
  Bunu engellemek için aşağıdakiler uygulanabilir:
    1- Eğer uygunsa, idle priority' deki ayrı tasklar yerine idle hook kullanılır
    2- Bütün oluşturulan task'lar idle priority'den daha yüksek öncelikli oluşturulur
    3- configIDLE_SHOULD_YIELD 0 olarak ayarlanır.
  configIDLE_SHOULD_YIELD'nin 0 olarak ayarlanması zaman diliminin sonuna kadar idle taskın processing time'ı harcamasına engel olmaktadır.
  Bu durum bütün idle priority'deki task'ların eşit processing time'ı almasını fakat toplamda idle task'ın daha yüksek oranda processing time
  maliyetine sahip olmasına neden olmaktadır.
  
  configUSE_TASK_NOTIFICATIONS -> configUSE_TASK_NOTIFICATIONS'nin 1 olarak ayarlanması (yada tanımsız olarak bırakılması) 'direct to task notification' 
  fonksiyonalitesine ve derleme içinde API'nin ilişkilendirilmesini içermektedir. Eğer  0 olarak ayarlanırsa yukarıdaki durumlar kapsam dışına çıkmaktadır.
  'direct to task notification'nin build içerisindeki dahili olma maliyeti her bir task başına 8 ekstra byte'dır.
  
  configUSE_MUTEXES -> 1 olarak ayarlanması build esnasında mutex'in dahil edilmesine sebep olmaktadır. 
  
  configUSE_RECURSIVE_MUTEXES -> 1 olarak ayarlanması build esnasında recursive mutex'in dahil edilmesine sebep olmaktadır. 
  
  configUSE_COUNTING_SEMAPHORES -> 1 olarak ayarlanması build esnasında counting semaphore'un dahil edilmesine sebep olmaktadır. 
  
  configUSE_ALTERNATIVE_API -> 1 olarak ayarlanması build esnasında 'alternative' queue function'ın dahil edilmesine sebep olmaktadır. 
  alternative API yeni tasarımlarda kullanılmaktadır.
  
  configCHECK_FOR_STACK_OVERFLOW -> stack overflow detection sayfası bu parametrenin kullanımını tanımlamaktadır.
  
  configQUEUE_REGISTRY_SIZE -> Queue registry'nin 2 amacı vardır, her ikisi de RTOS kernel farkındalıklı debuggin'dir: 
    1- GUI debugging içerisindeki kolay queue tanımlaması için olan queue ile alakalı metinsel isime izin verir.
    2- Her bir registered queue ve semafor için yerleşmeyi amaçlayan debugger tarafından ihtiyaç duyulan bilgiyi içerir.
  RTOS kernel farkındaliklı debugger'ı kulllanmadıkça queue register'ın bir amacı yoktur.
  configQUEUE_REGISTRY_SIZE register edilebilen maksimum sayıdaki queue ve semafor'u tanımlamaktadır.
  Yalnızca RTOS kernel farkındalıklı debugger kullanarak bu görmek istedğiniz queueu'lar ve semafor'ların kaydedilmeye(registered) ihtiyaç duyulur.
  vQueueAddToRegistry() ve vQueueUnregisterQueue() hakkında daha fazla bilgi için API referans dokümanına bakınız.
  
  configUSE_QUEUE_SETS -> queue set fonksiyonalitesi içermesi için (çoklu queue ve semafor üzerindeki block, yada pend imkanı için) 1 olarak 
  ayarlanmaktadır.
  
  configUSE_TIME_SLICING -> Varsayılanda (configUSE_TIME_SLICING tanımlanmamışsa yada 1 olarak tanımlanmışsa) FreeRTOS önceliklendirilmiş(prioritised) preempting scheduling'i time slicing ile 
  birlikte kullanır. Bu durum RTOS scheduler her zaman hazır durumda olanlardan en yüksek öncelikli task'ı kullandığı durumdur, ve bütün RTOS tick interrupt'ında 
  bütün eşit priority'li task'lar arasında anahtarlama yapmaktadır. Eğer configUSE_TIME_SLICING 0 olarak ayarlanırsa 
  yine RTOS scheduler her zaman hazır durumda olanlardan en yüksek öncelikli task'ı kullanır fakat hazır durumdaki bütün eşit priority'li
  task'lar arasında anahtarlama yapmamaktadır.
  
  configUSE_NEWLIB_REENTRANT -> Eğer configUSE_NEWLIB_REENTRANT 1 olarak ayarlanırsa bunu müteakip newlib reent yapısı her bir task 
  için yerleştirilecektir.
  
  FreeRTOS newlib desteğini kendisi sağlamamaktadır. Bu sebeple kullanıcılar kullanım esnasında kendileri dikkat etmelidir.
  
  configENABLE_BACKWARD_COMPATIBILITY -> Eğer 0 olarak tanımlanırsa önceki versiyonlardan gelen veri tipleri dahil edilmemektedir.
  
  configNUM_THREAD_LOCAL_STORAGE_POINTERS -> Her bir task'ın thread local storage array'ı içerisindeki indekslerin sayısı ayarlanır.
  
  configSUPPORT_STATIC_ALLOCATION -> Eğer 1 olarak ayarlanırsa RTOS nesneleri uygulamayı yazan kişi tarafından önceden belirtildiği
  şekilde sağlanan RAM alanı kullanılarak yaratılabilmektedir.
  Eğer 0 olarak ayarlanırsa RTOS nesneleri FreeRTOS heap'inden alınan RAM alanı kullanılarak yaratilabilmektedir.
  Eğer tanımsız olarak bırakılırsa, 0 olarak ayarlandığı durumdaki gibi bir RTOS nesnesi yaratma yolu izlenmektedir.
  1 olarak ayarlandığı durumda kodlayıcının sağlaması gereken 2 callback fonksiyonu vardır. Bunlardan biri  vApplicationGetIdleTaskMemory() 
  fonksiyonudur. Bu fonksiyon RTOS idle task'ın kullaması için gereken hafıza alanını sağlamakta ve(eğer configUSE_TIMERS 1 olarak ayarlanmış ise)
  diğeri ise  vApplicationGetTimerTaskMemory() fonksiyonu olup RTOS Daemon/Time servis task'ı için gerekli hafıza alanını sağlamaktadır.
  Örnekleri aşağıda gösterilmiştir:
----------------------------------------------------------------------------------------------------------------------------------    
    /* configSUPPORT_STATIC_ALLOCATION is set to 1, so the application must provide an
  implementation of vApplicationGetIdleTaskMemory() to provide the memory that is
  used by the Idle task. */
  void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer,
                                      StackType_t **ppxIdleTaskStackBuffer,
                                      uint32_t *pulIdleTaskStackSize )
  {
  /* If the buffers to be provided to the Idle task are declared inside this
  function then they must be declared static - otherwise they will be allocated on
  the stack and so not exists after this function exits. */
  static StaticTask_t xIdleTaskTCB;
  static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

      /* Pass out a pointer to the StaticTask_t structure in which the Idle task's
      state will be stored. */
      *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;

      /* Pass out the array that will be used as the Idle task's stack. */
      *ppxIdleTaskStackBuffer = uxIdleTaskStack;

      /* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.
      Note that, as the array is necessarily of type StackType_t,
      configMINIMAL_STACK_SIZE is specified in words, not bytes. */
      *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  }
  /*-----------------------------------------------------------*/

  /* configSUPPORT_STATIC_ALLOCATION and configUSE_TIMERS are both set to 1, so the
  application must provide an implementation of vApplicationGetTimerTaskMemory()
  to provide the memory that is used by the Timer service task. */
  void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer,
                                       StackType_t **ppxTimerTaskStackBuffer,
                                       uint32_t *pulTimerTaskStackSize )
  {
  /* If the buffers to be provided to the Timer task are declared inside this
  function then they must be declared static - otherwise they will be allocated on
  the stack and so not exists after this function exits. */
  static StaticTask_t xTimerTaskTCB;
  static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

      /* Pass out a pointer to the StaticTask_t structure in which the Timer
      task's state will be stored. */
      *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;

      /* Pass out the array that will be used as the Timer task's stack. */
      *ppxTimerTaskStackBuffer = uxTimerTaskStack;

      /* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer.
      Note that, as the array is necessarily of type StackType_t,
      configTIMER_TASK_STACK_DEPTH is specified in words, not bytes. */
      *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
  }
------------------------------------------------------------------------------------------------------------------------------------  
  configSUPPORT_DYNAMIC_ALLOCATION -> Eğer 1 olarak ayarlanırsa RTOS nesneleri FreeRTOS heap'inden otomatik olarak tahsis edilen RAM hafıza alanı 
  kullanılarak yaratılmaktadır.
  Eğer 0 olarak ayarlanırsa RTOS nesneleri sadece kodlayıcı tarafından belirtilen RAM hafıza alanı kullanılarak yaratılabilmektedir.
  Eğer tanımsız olarak bırakılırsa 1 olarak ayarlanmış gibi davranmaktadır.
  
  configTOTAL_HEAP_SIZE -> FreeRTOS heap'i üzerindeki toplam erişilebilir RAM alanını temsil etmektedir.
  Bu değer yalnızca eğer configSUPPORT_DYNAMIC_ALLOCATION 1 olarak ayarlanılırsa kullanılabilir ve uygulama FreeRTOS kaynak kodu yüklendiğinde 
  beraberinde gelen temel hafıza yerleşim şemalarının birinden faydalanır. Daha detaylı bilgi için 'memory configuration' kısmı incelenmelidir.
  
  configAPPLICATION_ALLOCATED_HEAP -> Varsayılanda FreeRTOS heap FreeRTOS tarafından deklare edilir ve linker tarafından hafızaya yerleştirilir.
  Eğer bu değişken 1 olarak ayarlanırsa uygulamayı kodlayan yukarıdaki işlemleri istediği gibi yapabilmektedir.
  Eğer heap_1.c,heap_2.c yada heap_4.c kullanılırsa ve configAPPLICATION_ALLOCATED_HEAP 1 olarak ayarlanırsa bunu müteakip uygulamayı kodlayan 
  aşağıda belirtildiği üzere belirrli bir isme ve boyuta sahip bir uin8_t dizisi oluştumalıdır. Bu dizi FreeRTOS heap olarak kullanılacaktır.
  Dizini belirli bir hafoza alanına nasıl yerleştirileceği derleyiciye bağlıdır.
  uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
  
  configGENERATE_RUN_TIME_STATS -> Run Time Stats sayfasında bu parametrenin kullanımı açıklanmaktadır.
  
  configUSE_CO_ROUTINES -> Eğer 1 olarak ayarlanırsa coroutine derleme içerisinde değerlendirilir. Bunun sağlanması için croutine.c
  dosyası da proje içerisinde yer almalıdır.
  
  configMAX_CO_ROUTINE_PRIORITIES -> Uygulama coroutine'leri için erişilebilir priority'lerin sayısını belirtmektedir. Herhangi sayıdaki
  co-routine aynı priority'yi paylaşabilmektedir.Task'lar ayrıca önceliklendirilir(prioritised) - configMAX_PRIORITIES'i inceleyiniz.
  
  configUSE_TIMERS -> Yazılımsal timer fonksiyonalitesini kullanabilmek için 1 olarak ayarlanması gerekmektedir. Tam tanım için 
  'FreeRTOS software timers' sayfasını inceleyiniz.
  
  configTIMER_TASK_PRIORITY -> Yazılımsal zamanlayıcı servis/daemon task'ın önceliği(priority)ni ayarlamak için ayarlanmaktadır.
  Tam tanım için 'FreeRTOS software timers' sayfasını inceleyiniz.
  
  configTIMER_QUEUE_LENGTH -> Yazılımsal zamanlayıcı komut queue'sinin uzunluğunu ayarlamak için kullanılmaktadır. Tam tanım için 'FreeRTOS software timers' sayfasını inceleyiniz.
  
  configTIMER_TASK_STACK_DEPTH -> Yazılımsal zamanlayıcı servis/daemon task için stack derinlik yerleşimini ayarlamak için kullanılmaktadır.
  
  configKERNEL_INTERRUPT_PRIORITY
  configMAX_SYSCALL_INTERRUPT_PRIORITY ve
  configMAX_API_CALL_INTERRUPT_PRIORITY -> configKERNEL_INTERRUPT_PRIORITY ayar makrosunu içeren port'lar  ARM Cortex-M3, PIC24, dsPIC, PIC32, SuperH 
  ve RX600 mikrokontrolör ailelerini içermekte, configMAX_SYSCALL_INTERRUPT_PRIORITY ayar makrosunu içeren port'lar PIC32, RX600, ARM Cortex-A 
  ve ARM Cortex-M mikrokojntrlör ailelelerini içermektedir. 
  Cortex-M3 ve Cortex-M4 mikrokontrolör ailelerini kullanan kullanıcılar bu bölümün sonundaki notlara dikkat etmelidir.
  configMAX_API_CALL_INTERRUPT_PRIORITY, configMAX_SYSCALL_INTERRUPT_PRIORITY'nin daha yeni port'lar için kullanılan güncel versiyonudur.
  İkisi birbirinin dengidir.
  configKERNEL_INTERRUPT_PRIORITY, en düşük priority ile ayarlanmalıdır.
  Dikkat edilmesi gereken husus aşağıda yalnızca "FromISR"nin sonundaki API fonksiyonlarıdır ki interrupt servis routine içerisinden çağırılabilsin.
  Yalnızca configKERNEL_INTERRUPT_PRIORITY'yi implemente eden portlar için:
  configKERNEL_INTERRUPT_PRIORITY, RTOS kernel'in kendi tarafından kullanılan interrupt priority ayarlar. API fonksiyonlarını çağıran
  interrput'lar da bu priority'de çalışmalıdır. API fonksiyonlarını çağırmayan interrupt'lar daha yüksek priority'de çalışabilirler ve
  bundan dolayı asla RTOS kernel aktivitesi tarafından çalışmaları geciktirilemez(donanımın kendi limitleri içerisinde).
  configKERNEL_INTERRUPT_PRIORITY ve configMAX_SYSCALL_INTERRUPT_PRIORITY'nin her ikisini de implemente eden portlar için:
  configKERNEL_INTERRUPT_PRIORITY, RTOS kernel'inin kendisi tarafından kullanılan interrupt priority'yi ayarlar. 
  configMAX_SYSCALL_INTERRUPT_PRIORITY, interrupt safe FreeRTOS API fonksiyonlarının çağırılabilenlerinden en yüksek interrupt priority'li 
  olanı ayarlamak için kullanılır.
  "Full interrupt nesting model" configMAX_SYSCALL_INTERRUPT_PRIORITY'nin configKERNEL_INTERRUPT_PRIORITY'den daha yüksek olarak (daha yüksek priority seviyesinde)
  ayarlanması ile elde edilir.Bu şu anlama gelir ki kritik kısımlarda(critical sections) bile FreeRTOS kernel'i interrupt'ları tamamıyle 
  etkisizleştiremez. Dahası bu bölünmüş kernel(çekirdek) mimarisnin dezavantajları olmaksızın elde edilir. Buna rağmen dikkat edilmelidir ki,
  belirli mikrokontrolör mimarileri(donanım içerisinde) yeni bir interrupt alındığında interruptları etkisizleştirecektir - bu şu anlam gelir ki
  interrupt'lar kısa bir süre istenmeyen bir şekilde donanımın interrupt'ı kabul etmesi ile FreeRTOS'un interrupt'ları tekrar etkinleştirmesi arasında 
  etkisizleştirir.
  Interrupt'lar configMAX_SYSCALL_INTERRUPT_PRIORITY'nin üzerindeki priority'de çalışan API fonksiyonlarını çağıramamaktadır 
  ve bundan dolayı RTOS kernel çalışması tarafından geciktirilemezler.
  Örenğin, varsayımsal olarak 8 interrupt seviyesine sahip bir mikrokontrolör olsun. 0 en düşük ve 7 en yüksek priority seviyesi 
  olsun (cortex M3 ve M4'ün durumu biraz farklıdır. Bu mikrokontrolör ailelerinde en yüksek priority seviyesi en düşük numaralı priority'dir)
  Bu konfigürasyon parametreleri çok esnek interrupt handling'e izin vermektedir:
    - interrupt handling 'task'lar sistemdeki diğer task'lar gibi yazılabilir ve önceliklendirilebilir(prioritised). Bu tasklar interrupt
    tarafından uyandırılabilir. ISR mümkün olduğunca kısa tutulur ve bitişinde mevcut handle edilmiş task'a geri dönülür.
    - configMAX_SYSCALL_INTERRUPT_PRIORITY'yi implemente eden portlar işi bunun da ötesine götürüp bütünüyle RTOS kernel interrupt priority ile configMAX_SYSCALL_INTERRUPT_PRIORITY arasında
    nested yapı kullanabilir ve uygulalanılabilir API çağırmaları icra edilebilir. configMAX_SYSCALL_INTERRUPT_PRIORITY üzerindeki priority seviyesindeki interruptlar RTOS kernel aktivites, ile geciktirilemezler.
    - Maksimum syscall priority'si üzerindeki ISR çalışması RTOS kernelin kendi tarafından asla maskelemeden çıkarılamaz, bundan dolayı 
    cevap verme süresi RTOS kernelin fonksiyonalitesi tarafından etkilenmez.Bu durum çok sık zaman aralığında gerçekleşen motor komitasyonu gerçekleşteren
    interruptlar gibi interruptlarda idealdir. Buna rağmen, böyle ISR'lar FreeRTOS API kullanamazlar.
  Bu şemadan faydalanabilmek için uygulama tasarımınız şu kurala bağımlı kalmak zorundadır: FreeRTOS API'yi kullanan herhangi bir interrupt
  RTOS kernel ile aynı priority'de olmalıdır, yada bu fonksiyonaliteyi içeren portlar configMAX_SYSCALL_INTERRUPT_PRIORITY  ile aynı yada daha düşük seviyede olmalıdır.
  Cortex M3 ve Cortex M4'te bunun tersi bir durum geçerlidir. Yüksek öncelikli priority'nin rakam olarak değeri düşüktür. Yani en yüksek öncelikli
  priority seviyesi 0'dır. 
  
  configASSERT -> configASSERT()'in yapısı genel olarak C'deki ASSERT() ile aynıdır. Eğer configASSERT()'e geçen parametre sıfır ise 
  bir assertion meydana gelir.
  Eğer kodun herhangi bir noktasında problem varsa kodun bu nokta durarak crash olmasını sağlamaktadır. Kod boyutunu arttırmaktadır. 
  Eğer bu durum problem ise istenilen noktaladaki assert'ler comment out edilebilir.
  Aşağıda örnek kullanımlar gösterilmiştir:
  
  /* Define configASSERT() to call vAssertCalled() if the assertion fails.  The assertion
  has failed if the value of the parameter passed into configASSERT() equals zero. */
  #define configASSERT( ( x ) )     if( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )
  
  /* Define configASSERT() to disable interrupts and sit in a loop. */
  #define configASSERT( ( x ) )     if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }
  
  configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS -> Yalnızca FreeRTOS MPU'su tarafından kullanılır.
  Eğer 1 olarak ayarlanmışsa kodlayıcı  uygulamayı yazanın priveleged modda çalıştırmaya ihtiyaç duyacağı fonksiyonları 
  implemete edilebilmesi için "application_defined_privileged_functions.h" isminde bir başlık dosyası sağlamalıdır.
  Bu bir başlık dosyası olmasına rağmen fonksiyonların sadece prototiplerini içermemelidir. Aynı zamanda implementasyonlarını da
  içermelidir.
  "application_defined_privileged_functions.h" başlık dosyasında implemente edilen fonksiyonlar 
  prvRaisePrivilege() fonksiyonunu ve portRESET_PRIVILEGE() makrosunu kullanarak işlemcinin privelege state'ini kaydetmeli ve tekrar yüklemelidir.
  Örneğin eğer kütüphanenin sağlamış olduğu kodu yazanın kontrolü dışında RAM'e ulaşan bir print fonksiyonu varsa ve bundan dolayı bu fonksiyon 
  hafıza korumalı kullanıcı modundaki task'a yerleştirilemiyorsa, aşağıdaki kod örneği kullanılarak bu print fonksiyonu priveleged fonksiyonun
  içerisine enkapsüle edilebilir.
  void MPU_debug_printf( const char *pcMessage )
  {
    /* State the privilege level of the processor when the function was called. */
    BaseType_t xRunningPrivileged = prvRaisePrivilege();

    /* Call the library function, which now has access to all RAM. */
    debug_printf( pcMessage );

    /* Reset the processor privilege level to its original value. */
    portRESET_PRIVILEGE( xRunningPrivileged );
  }
  
  Bu teknik hafıza korumadan kaçınmak için yalnızca development esnasında kullanılmalıdır, deployment esnasında değil.
  
  INCLUDE Parameters -> INCLUDE ile başlayan makrolar uygulamanız tarafından sağlanmayan real time kernel'in bu komponentlerinin derlemenizin 
  dışında kalmasını izin vermektedir. Bu durum RTOS'un sizin özel gömülü uygulamanızın ihtiyaç duyduğu RAM ve ROM'u kullanmamasını 
  sağlamaktadır.
  Her makro şu şekilde bir fomra sahiptir...
  INCLUDE_FunctionName
  ..buradaki FunctionName ibaresi opsiyonel olarak exclude edilebilen API fonksiyonunu (yada bir kısım fonksiyon setini) belirtmektedir.
  Include için 1 olarak exclude için 0 olarak ayarlanmalıdır.
  Örneğin vTaskDelete() API fonksiyonunu include etmek için:
  #define INCLUDE_vTaskDelete    1
  derlemeden exclude etmek için ise:
  #define INCLUDE_vTaskDelete    0 
  kullanılır.
  
  
  HAFIZA YÖNETİMİ:
  RTOS kerneli her task, queue, mutex, software timer, semafor yada event group yaratıldığında RAM'e ihtiyaç duymaktadır.
  RAM RTOS heap'inden otomatik olarak RTOS API'si nesne yaratma fonksiyonları ile otomatik olarak yada uygulamayı kodlayan 
  tarafından yaratılabilmektedir. 
  FreeRTOS portable katmanında API hafıza tahsisini icra etmektedir. malloc ve free yerine pvPortMalloc() ve vPortFree() 
  kullanılmaktadır. 
  RTOS Kaynak Kodu İçindeki hafıza yerleşimi uygulamaları:
  
  
  
  
  
  
  
  
