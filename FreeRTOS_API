                                                KONFİGÜRASYON
KUSTOMİZASYON:
Bu parametreler birer macro(define)'dur. Tanım değerine göre FreeRTOS farklı konfigürasyona ayarlanabilmektedir.

configUSE_PREEMPTION -> Eğer 1 olarak tanımlanırsa preemptive RTOS scheduler, 0 olarak tanımlanırsa 
cooperative RTOS scheduler kullanılacaktır.

configUSE_PORT_OPTIMISED_TASK_SELECTION -> Bazı FreeRTOS portlarının bir sonraki task'ın çalışması için seçebileceği 2 method bulunmaktadır.
Bu methodlar, generic method ve bu porta özel olan methoddur. 
  Generic Method: 
    - configUSE_PORT_OPTIMISED_TASK_SELECTION 0 olarak ayarlandığında, yada bu porta özel method uygulanmadığında kullanılmaktadır.
    - bütün FreeRTOS portları ile kullanılabilmektedir.
    - bütünüyle C dilinde yazılmıştır, bu durum porta özel methoda göre daha az etkin olmasına neden olmaktadır.
    - erişilebilir priority'lerin sayısının belli bir üst limiti aşmamasına zorlamamaktadır.
  Porta özel method:
    - bütün portlar için erişilebilir değildir.
    - configUSE_PORT_OPTIMISED_TASK_SELECTION 1 olarak ayarlandığında kullanılır.
    - bir yada daha fazla mimariye özel assembly instruction'larına bağlıdır (tipik olarak Count Leading Zeros(CLZ) yada eşdeğer instruction)bundan dolayı özel olarak yazıldığı mimariyle birlikte kullanılabilmektedir.
    - generic method'dan daha etkindir.
    - Tipik olarak maksimum erişilebilir priority sayısı 32 ile sınırlı olmaya zorlanmaktadır.
  
 configUSE_TICKLESS_IDLE -> 'low power tickless mode' ile kullanılması için 1 olarak, yada tick interrupt çalışmayı devamlı çalıştırmak için 0 olarak
 ayarlanır.
 
 configUSE_IDLE_HOOK -> idle hook kullanılacaksa 1 olarak, bir idle hook' u ihmal etmek için ise 0 olarak ayarlanmaktadır.
 
 configUSE_MALLOC_FAILED_HOOK -> kernel, her task, queue yada semafor yaratıldığında heap'ten bir hafıza alanını pvPortMalloc() kullanarak tahsis eder.
 Bu amaçla FreeRTOS'un yüklendiğinde içerisinde bulunan 4 temel hafıza tahsis şeması vardır. heap_1.c, heap_2.c, heap_3.c, heap_4.c ve heap_5.c  kaynak dosyalarında uygulanan
 bu şemalar uygulanmaktadır. configUSE_MALLOC_FAILED_HOOK bu üç şema durumuna uygun olarak uygulanmaktadır.
 malloc() hook fonksiyonu uygulamada hata vermektedir ki bu durumda pvPortMalloc() NULL dönmektedir. NULL yalnızca geri kalan FreeRTOS hafızası 
 başarılı bir yer tahsisi için yetersiz kaldığında geri dönüş değeri olmaktadır.
 Eğer configUSE_MALLOC_FAILED_HOOK 1 olarak ayarlanırsa bir malloc() failed fonksiyonu tanımlanmalıdır. Eğer 0 olarak ayarlanmışsa tanımlanmış olsa bile 
 geri dönmez. Malloc() failed fook fonksiyonunun isimi ve prototip tanımı aşağıda gösterilmiştir.
  void vApplicationMallocFailedHook( void );
 
 configUSE_DAEMON_TASK_STARTUP_HOOK -> Eğer configUSE_TIMERS ve configUSE_DAEMON_TASK_STARTUP_HOOK'nun her ikisi de 1 olarak ayarlanmışsa
 aşağıda gösterildiği şekilde bir isme ve prototipe sahip bir hook fonksiyonu tanımlanmalıdır. Hook fonksiyonu RTOS deamon task(timer servis task' da denilmektedir) 
 ilk defa çalıştığında tam olarak 1 kere çağırılmalıdır. RTOS'un çalışması için gereken herhangi bir uygulamanın ilklendirme hook fonksiyonu içerisine yerleştirilebilmektedir.
  void void vApplicationDaemonTaskStartupHook( void );
  
  configUSE_TICK_HOOK -> 'tick hook'u kullanmak istiyorsak 1 olarak, istemiyorsak 0 olarak ayarlamamız gerekmektedir.
  
  configCPU_CLOCK_HZ -> çevresel birimin kullanması için sürülen dahili(internal) clock'un girilir ki bu değeri genelde dahili CPU clock 
  üretmektedir. Bu değer timer'ları düzgün bir şekilde konfigüre etmek için gerekmektedir.
  
  configTICK_RATE_HZ -> RTOS tick interrupt'ın frekansıdır. 
  tick interrupt zamanı ölçmek için kullanılmaktadır. Bundan dolayı daha yüksek tick frekansına sahip olmak zamanın daha yüksek bir
  çözünürlükle ölçülebilmesini sağlamaktadır.
  
  configMAX_PRIORITIES -> Uygulama task'ı için erişilebilir priority'lerin sayısıdır. Herhangi bir sayıdaki task aynı priority'yi paylaşabilmektedir.
  Coroutine'ler ayrıca önceliklendirileceklerdir (prioritised) - configMAX_CO_ROUTINE_PRIORITIES'i inceleyiniz.
  Herbir erişilebilir priority, RTOS kernel'i içerisindeki RAM'i tüketmektedir ki bundan dolayı sizin uygulamanız tarafından gerçekte istenenden 
  daha yüksek olmamalıdır.
  
  configMINIMAL_STACK_SIZE -> Idle task tarafından kullanılan stack'in boyutudur. Genelde kullanmakta olduğunuz port için olan demo ı-uygulaması 
  ile gelen FreeRTOSConfig.h'im içerisindeki değerden elde edilmemelidir.
  xTaskCreate() ve xTaskCreateStatic() fonksiyonları için olan stack size parametrelerinde olduğu gibi, stack size word cinsinden 
  belirtilmektedir, byte cinsinden değil.
  Stack'teki her bir item 32 bit değerlikli ise, stack size'ın 100 olması 400 byte'lık bir alanı temsil etmektedir (her bir 32 bit'lik stack itemi 4 byte'ı temsil etmektedir).
  
  configMAX_TASK_NAME_LEN -> Task yaratılırken tanımlatıcı ismin müsade edilebilir maksimum uzunluğunu temsil etmektedir. NULL termination byte'ı da içerecek
  şekilde toplam karakter sayısının değeridir.
  
  configUSE_TRACE_FACILITY -> Eğer visualisation ve tracing çalışması ile ek structure member'ların ve fonksiyonların da dahil olması
  isteniyorsa 1 olarak ayarlanmalıdır.
  
  configUSE_STATS_FORMATTING_FUNCTIONS -> Build esnasında vTaskList() ve vTaskGetRunTimeStats() fonksiyonlarının da dahil olması 
  isteniyorsa configUSE_TRACE_FACILITY ve configUSE_STATS_FORMATTING_FUNCTIONS 1 olarak ayarlanmalıdır. Build esnasında ihmal etmek için ise
  0 olarak ayarlanmalıdır.
  
  configUSE_16_BIT_TICKS -> Zaman, RTOS kerneli çalışmaya başladığından beri tick interrupt'ının meydana gelme sayısını temsil eden 'ticks' 
  ile ölçülmektedir.
  configUSE_16_BIT_TICKS'nin 1 olarak ayarlanması TickType_t'nin 16 bit olarak tanımlanmasına, 0 ayarlanması 32 bit olarak tanımlanmasına 
  neden olmaktadır.
  16 bit tip kullanılması 8 bit ve 16 bit mimari için performansı arttırmaktadır fakat zaman periyodunu 65535 tick ile sınırlamaktadır. Bu durumda örneğin
  250 Hz tick frekansı için maksimum gecikme süresi 262 saniyedir fakat 32 bit tip sayıcı kullanılsa 17179869 saniye gecikme verilebilir.
  
  configIDLE_SHOULD_YIELD -> Bu parametre idle priority için task'ların davranışını kontrol eder. Yalnızca etki ettiği durum:
    1- Preemptive scheduler kullanıldığında.
    2- Uygulama idle priority'de çalışan task'lar yarattığında.
  Eğer configUSE_TIME_SLICING 1 olarak ayarlanırsa(yada tanımsızsa) aynı priority'yi paylaşan task'lar zamanı dilimleyeceklerdir. Eğer 
  hiç bir task preempt edilmemişse verilen priority'deki her bir task zamanı eşit zaman diliminde çalışırlar - bu durum gerçekte idle priority'nin
  üstündeki değer için geçerlidir.
  Eğer task'lar idle priority değerinde ise davranışları değişmektedir. Eğer configIDLE_SHOULD_YIELD 1 olaraak set edilmişse idle task başka 
  idle prioty'li task ayarlanmış olsa da hemen çalışır. Bu durum idle task çalıştığı esnada çalışan idle priority'li task'ın diğer diğer idle priority'li
  task'lardan daha az süre almasına sebep olur.
  Bunu engellemek için aşağıdakiler uygulanabilir:
    1- Eğer uygunsa, idle priority' deki ayrı tasklar yerine idle hook kullanılır
    2- Bütün oluşturulan task'lar idle priority'den daha yüksek öncelikli oluşturulur
    3- configIDLE_SHOULD_YIELD 0 olarak ayarlanır.
  configIDLE_SHOULD_YIELD'nin 0 olarak ayarlanması zaman diliminin sonuna kadar idle taskın processing time'ı harcamasına engel olmaktadır.
  Bu durum bütün idle priority'deki task'ların eşit processing time'ı almasını fakat toplamda idle task'ın daha yüksek oranda processing time
  maliyetine sahip olmasına neden olmaktadır.
  
  configUSE_TASK_NOTIFICATIONS -> configUSE_TASK_NOTIFICATIONS'nin 1 olarak ayarlanması (yada tanımsız olarak bırakılması) 'direct to task notification' 
  fonksiyonalitesine ve derleme içinde API'nin ilişkilendirilmesini içermektedir. Eğer  0 olarak ayarlanırsa yukarıdaki durumlar kapsam dışına çıkmaktadır.
  'direct to task notification'nin build içerisindeki dahili olma maliyeti her bir task başına 8 ekstra byte'dır.
  
  configUSE_MUTEXES -> 1 olarak ayarlanması build esnasında mutex'in dahil edilmesine sebep olmaktadır. 
  
  configUSE_RECURSIVE_MUTEXES -> 1 olarak ayarlanması build esnasında recursive mutex'in dahil edilmesine sebep olmaktadır. 
  
  configUSE_COUNTING_SEMAPHORES -> 1 olarak ayarlanması build esnasında counting semaphore'un dahil edilmesine sebep olmaktadır. 
  
  configUSE_ALTERNATIVE_API -> 1 olarak ayarlanması build esnasında 'alternative' queue function'ın dahil edilmesine sebep olmaktadır. 
  alternative API yeni tasarımlarda kullanılmaktadır.
  
  configCHECK_FOR_STACK_OVERFLOW -> stack overflow detection sayfası bu parametrenin kullanımını tanımlamaktadır.
  
  configQUEUE_REGISTRY_SIZE -> Queue registry'nin 2 amacı vardır, her ikisi de RTOS kernel farkındalıklı debuggin'dir: 
    1- GUI debugging içerisindeki kolay queue tanımlaması için olan queue ile alakalı metinsel isime izin verir.
    2- Her bir registered queue ve semafor için yerleşmeyi amaçlayan debugger tarafından ihtiyaç duyulan bilgiyi içerir.
  RTOS kernel farkındaliklı debugger'ı kulllanmadıkça queue register'ın bir amacı yoktur.
  configQUEUE_REGISTRY_SIZE register edilebilen maksimum sayıdaki queue ve semafor'u tanımlamaktadır.
  Yalnızca RTOS kernel farkındalıklı debugger kullanarak bu görmek istedğiniz queueu'lar ve semafor'ların kaydedilmeye(registered) ihtiyaç duyulur.
  vQueueAddToRegistry() ve vQueueUnregisterQueue() hakkında daha fazla bilgi için API referans dokümanına bakınız.
  
  configUSE_QUEUE_SETS -> queue set fonksiyonalitesi içermesi için (çoklu queue ve semafor üzerindeki block, yada pend imkanı için) 1 olarak 
  ayarlanmaktadır.
  
  configUSE_TIME_SLICING -> Varsayılanda (configUSE_TIME_SLICING tanımlanmamışsa yada 1 olarak tanımlanmışsa) FreeRTOS önceliklendirilmiş(prioritised) preempting scheduling'i time slicing ile 
  birlikte kullanır. Bu durum RTOS scheduler her zaman hazır durumda olanlardan en yüksek öncelikli task'ı kullandığı durumdur, ve bütün RTOS tick interrupt'ında 
  bütün eşit priority'li task'lar arasında anahtarlama yapmaktadır. Eğer configUSE_TIME_SLICING 0 olarak ayarlanırsa 
  yine RTOS scheduler her zaman hazır durumda olanlardan en yüksek öncelikli task'ı kullanır fakat hazır durumdaki bütün eşit priority'li
  task'lar arasında anahtarlama yapmamaktadır.
  
  configUSE_NEWLIB_REENTRANT -> Eğer configUSE_NEWLIB_REENTRANT 1 olarak ayarlanırsa bunu müteakip newlib reent yapısı her bir task 
  için yerleştirilecektir.
  
  FreeRTOS newlib desteğini kendisi sağlamamaktadır. Bu sebeple kullanıcılar kullanım esnasında kendileri dikkat etmelidir.
  
  configENABLE_BACKWARD_COMPATIBILITY -> Eğer 0 olarak tanımlanırsa önceki versiyonlardan gelen veri tipleri dahil edilmemektedir.
  
  configNUM_THREAD_LOCAL_STORAGE_POINTERS -> Her bir task'ın thread local storage array'ı içerisindeki indekslerin sayısı ayarlanır.
  
  configSUPPORT_STATIC_ALLOCATION -> Eğer 1 olarak ayarlanırsa RTOS nesneleri uygulamayı yazan kişi tarafından önceden belirtildiği
  şekilde sağlanan RAM alanı kullanılarak yaratılabilmektedir.
  Eğer 0 olarak ayarlanırsa RTOS nesneleri FreeRTOS heap'inden alınan RAM alanı kullanılarak yaratilabilmektedir.
  Eğer tanımsız olarak bırakılırsa, 0 olarak ayarlandığı durumdaki gibi bir RTOS nesnesi yaratma yolu izlenmektedir.
  1 olarak ayarlandığı durumda kodlayıcının sağlaması gereken 2 callback fonksiyonu vardır. Bunlardan biri  vApplicationGetIdleTaskMemory() 
  fonksiyonudur. Bu fonksiyon RTOS idle task'ın kullaması için gereken hafıza alanını sağlamakta ve(eğer configUSE_TIMERS 1 olarak ayarlanmış ise)
  diğeri ise  vApplicationGetTimerTaskMemory() fonksiyonu olup RTOS Daemon/Time servis task'ı için gerekli hafıza alanını sağlamaktadır.
  Örnekleri aşağıda gösterilmiştir:
----------------------------------------------------------------------------------------------------------------------------------    
    /* configSUPPORT_STATIC_ALLOCATION is set to 1, so the application must provide an
  implementation of vApplicationGetIdleTaskMemory() to provide the memory that is
  used by the Idle task. */
  void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer,
                                      StackType_t **ppxIdleTaskStackBuffer,
                                      uint32_t *pulIdleTaskStackSize )
  {
  /* If the buffers to be provided to the Idle task are declared inside this
  function then they must be declared static - otherwise they will be allocated on
  the stack and so not exists after this function exits. */
  static StaticTask_t xIdleTaskTCB;
  static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

      /* Pass out a pointer to the StaticTask_t structure in which the Idle task's
      state will be stored. */
      *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;

      /* Pass out the array that will be used as the Idle task's stack. */
      *ppxIdleTaskStackBuffer = uxIdleTaskStack;

      /* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.
      Note that, as the array is necessarily of type StackType_t,
      configMINIMAL_STACK_SIZE is specified in words, not bytes. */
      *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  }
  /*-----------------------------------------------------------*/

  /* configSUPPORT_STATIC_ALLOCATION and configUSE_TIMERS are both set to 1, so the
  application must provide an implementation of vApplicationGetTimerTaskMemory()
  to provide the memory that is used by the Timer service task. */
  void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer,
                                       StackType_t **ppxTimerTaskStackBuffer,
                                       uint32_t *pulTimerTaskStackSize )
  {
  /* If the buffers to be provided to the Timer task are declared inside this
  function then they must be declared static - otherwise they will be allocated on
  the stack and so not exists after this function exits. */
  static StaticTask_t xTimerTaskTCB;
  static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

      /* Pass out a pointer to the StaticTask_t structure in which the Timer
      task's state will be stored. */
      *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;

      /* Pass out the array that will be used as the Timer task's stack. */
      *ppxTimerTaskStackBuffer = uxTimerTaskStack;

      /* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer.
      Note that, as the array is necessarily of type StackType_t,
      configTIMER_TASK_STACK_DEPTH is specified in words, not bytes. */
      *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
  }
------------------------------------------------------------------------------------------------------------------------------------  
  configSUPPORT_DYNAMIC_ALLOCATION -> Eğer 1 olarak ayarlanırsa RTOS nesneleri FreeRTOS heap'inden otomatik olarak tahsis edilen RAM hafıza alanı 
  kullanılarak yaratılmaktadır.
  Eğer 0 olarak ayarlanırsa RTOS nesneleri sadece kodlayıcı tarafından belirtilen RAM hafıza alanı kullanılarak yaratılabilmektedir.
  Eğer tanımsız olarak bırakılırsa 1 olarak ayarlanmış gibi davranmaktadır.
  
  configTOTAL_HEAP_SIZE -> FreeRTOS heap'i üzerindeki toplam erişilebilir RAM alanını temsil etmektedir.
  Bu değer yalnızca eğer configSUPPORT_DYNAMIC_ALLOCATION 1 olarak ayarlanılırsa kullanılabilir ve uygulama FreeRTOS kaynak kodu yüklendiğinde 
  beraberinde gelen temel hafıza yerleşim şemalarının birinden faydalanır. Daha detaylı bilgi için 'memory configuration' kısmı incelenmelidir.
  
  configAPPLICATION_ALLOCATED_HEAP -> Varsayılanda FreeRTOS heap FreeRTOS tarafından deklare edilir ve linker tarafından hafızaya yerleştirilir.
  Eğer bu değişken 1 olarak ayarlanırsa uygulamayı kodlayan yukarıdaki işlemleri istediği gibi yapabilmektedir.
  Eğer heap_1.c,heap_2.c yada heap_4.c kullanılırsa ve configAPPLICATION_ALLOCATED_HEAP 1 olarak ayarlanırsa bunu müteakip uygulamayı kodlayan 
  aşağıda belirtildiği üzere belirrli bir isme ve boyuta sahip bir uin8_t dizisi oluştumalıdır. Bu dizi FreeRTOS heap olarak kullanılacaktır.
  Dizini belirli bir hafoza alanına nasıl yerleştirileceği derleyiciye bağlıdır.
  uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
  
  configGENERATE_RUN_TIME_STATS -> Run Time Stats sayfasında bu parametrenin kullanımı açıklanmaktadır.
  
  configUSE_CO_ROUTINES -> Eğer 1 olarak ayarlanırsa coroutine derleme içerisinde değerlendirilir. Bunun sağlanması için croutine.c
  dosyası da proje içerisinde yer almalıdır.
  
  configMAX_CO_ROUTINE_PRIORITIES -> Uygulama coroutine'leri için erişilebilir priority'lerin sayısını belirtmektedir. Herhangi sayıdaki
  co-routine aynı priority'yi paylaşabilmektedir.Task'lar ayrıca önceliklendirilir(prioritised) - configMAX_PRIORITIES'i inceleyiniz.
  
  configUSE_TIMERS -> Yazılımsal timer fonksiyonalitesini kullanabilmek için 1 olarak ayarlanması gerekmektedir. Tam tanım için 
  'FreeRTOS software timers' sayfasını inceleyiniz.
  
  configTIMER_TASK_PRIORITY -> Yazılımsal zamanlayıcı servis/daemon task'ın önceliği(priority)ni ayarlamak için ayarlanmaktadır.
  Tam tanım için 'FreeRTOS software timers' sayfasını inceleyiniz.
  
  configTIMER_QUEUE_LENGTH -> Yazılımsal zamanlayıcı komut queue'sinin uzunluğunu ayarlamak için kullanılmaktadır. Tam tanım için 'FreeRTOS software timers' sayfasını inceleyiniz.
  
  configTIMER_TASK_STACK_DEPTH -> Yazılımsal zamanlayıcı servis/daemon task için stack derinlik yerleşimini ayarlamak için kullanılmaktadır.
  
  configKERNEL_INTERRUPT_PRIORITY
  configMAX_SYSCALL_INTERRUPT_PRIORITY ve
  configMAX_API_CALL_INTERRUPT_PRIORITY -> configKERNEL_INTERRUPT_PRIORITY ayar makrosunu içeren port'lar  ARM Cortex-M3, PIC24, dsPIC, PIC32, SuperH 
  ve RX600 mikrokontrolör ailelerini içermekte, configMAX_SYSCALL_INTERRUPT_PRIORITY ayar makrosunu içeren port'lar PIC32, RX600, ARM Cortex-A 
  ve ARM Cortex-M mikrokojntrlör ailelelerini içermektedir. 
  Cortex-M3 ve Cortex-M4 mikrokontrolör ailelerini kullanan kullanıcılar bu bölümün sonundaki notlara dikkat etmelidir.
  configMAX_API_CALL_INTERRUPT_PRIORITY, configMAX_SYSCALL_INTERRUPT_PRIORITY'nin daha yeni port'lar için kullanılan güncel versiyonudur.
  İkisi birbirinin dengidir.
  configKERNEL_INTERRUPT_PRIORITY, en düşük priority ile ayarlanmalıdır.
  Dikkat edilmesi gereken husus aşağıda yalnızca "FromISR"nin sonundaki API fonksiyonlarıdır ki interrupt servis routine içerisinden çağırılabilsin.
  Yalnızca configKERNEL_INTERRUPT_PRIORITY'yi implemente eden portlar için:
  configKERNEL_INTERRUPT_PRIORITY, RTOS kernel'in kendi tarafından kullanılan interrupt priority ayarlar. API fonksiyonlarını çağıran
  interrput'lar da bu priority'de çalışmalıdır. API fonksiyonlarını çağırmayan interrupt'lar daha yüksek priority'de çalışabilirler ve
  bundan dolayı asla RTOS kernel aktivitesi tarafından çalışmaları geciktirilemez(donanımın kendi limitleri içerisinde).
  configKERNEL_INTERRUPT_PRIORITY ve configMAX_SYSCALL_INTERRUPT_PRIORITY'nin her ikisini de implemente eden portlar için:
  configKERNEL_INTERRUPT_PRIORITY, RTOS kernel'inin kendisi tarafından kullanılan interrupt priority'yi ayarlar. 
  configMAX_SYSCALL_INTERRUPT_PRIORITY, interrupt safe FreeRTOS API fonksiyonlarının çağırılabilenlerinden en yüksek interrupt priority'li 
  olanı ayarlamak için kullanılır.
  "Full interrupt nesting model" configMAX_SYSCALL_INTERRUPT_PRIORITY'nin configKERNEL_INTERRUPT_PRIORITY'den daha yüksek olarak (daha yüksek priority seviyesinde)
  ayarlanması ile elde edilir.Bu şu anlama gelir ki kritik kısımlarda(critical sections) bile FreeRTOS kernel'i interrupt'ları tamamıyle 
  etkisizleştiremez. Dahası bu bölünmüş kernel(çekirdek) mimarisnin dezavantajları olmaksızın elde edilir. Buna rağmen dikkat edilmelidir ki,
  belirli mikrokontrolör mimarileri(donanım içerisinde) yeni bir interrupt alındığında interruptları etkisizleştirecektir - bu şu anlam gelir ki
  interrupt'lar kısa bir süre istenmeyen bir şekilde donanımın interrupt'ı kabul etmesi ile FreeRTOS'un interrupt'ları tekrar etkinleştirmesi arasında 
  etkisizleştirir.
  Interrupt'lar configMAX_SYSCALL_INTERRUPT_PRIORITY'nin üzerindeki priority'de çalışan API fonksiyonlarını çağıramamaktadır 
  ve bundan dolayı RTOS kernel çalışması tarafından geciktirilemezler.
  Örenğin, varsayımsal olarak 8 interrupt seviyesine sahip bir mikrokontrolör olsun. 0 en düşük ve 7 en yüksek priority seviyesi 
  olsun (cortex M3 ve M4'ün durumu biraz farklıdır. Bu mikrokontrolör ailelerinde en yüksek priority seviyesi en düşük numaralı priority'dir)
  Bu konfigürasyon parametreleri çok esnek interrupt handling'e izin vermektedir:
    - interrupt handling 'task'lar sistemdeki diğer task'lar gibi yazılabilir ve önceliklendirilebilir(prioritised). Bu tasklar interrupt
    tarafından uyandırılabilir. ISR mümkün olduğunca kısa tutulur ve bitişinde mevcut handle edilmiş task'a geri dönülür.
    - configMAX_SYSCALL_INTERRUPT_PRIORITY'yi implemente eden portlar işi bunun da ötesine götürüp bütünüyle RTOS kernel interrupt priority ile configMAX_SYSCALL_INTERRUPT_PRIORITY arasında
    nested yapı kullanabilir ve uygulalanılabilir API çağırmaları icra edilebilir. configMAX_SYSCALL_INTERRUPT_PRIORITY üzerindeki priority seviyesindeki interruptlar RTOS kernel aktivites, ile geciktirilemezler.
    - Maksimum syscall priority'si üzerindeki ISR çalışması RTOS kernelin kendi tarafından asla maskelemeden çıkarılamaz, bundan dolayı 
    cevap verme süresi RTOS kernelin fonksiyonalitesi tarafından etkilenmez.Bu durum çok sık zaman aralığında gerçekleşen motor komitasyonu gerçekleşteren
    interruptlar gibi interruptlarda idealdir. Buna rağmen, böyle ISR'lar FreeRTOS API kullanamazlar.
  Bu şemadan faydalanabilmek için uygulama tasarımınız şu kurala bağımlı kalmak zorundadır: FreeRTOS API'yi kullanan herhangi bir interrupt
  RTOS kernel ile aynı priority'de olmalıdır, yada bu fonksiyonaliteyi içeren portlar configMAX_SYSCALL_INTERRUPT_PRIORITY  ile aynı yada daha düşük seviyede olmalıdır.
  Cortex M3 ve Cortex M4'te bunun tersi bir durum geçerlidir. Yüksek öncelikli priority'nin rakam olarak değeri düşüktür. Yani en yüksek öncelikli
  priority seviyesi 0'dır. 
  
  configASSERT -> configASSERT()'in yapısı genel olarak C'deki ASSERT() ile aynıdır. Eğer configASSERT()'e geçen parametre sıfır ise 
  bir assertion meydana gelir.
  Eğer kodun herhangi bir noktasında problem varsa kodun bu nokta durarak crash olmasını sağlamaktadır. Kod boyutunu arttırmaktadır. 
  Eğer bu durum problem ise istenilen noktaladaki assert'ler comment out edilebilir.
  Aşağıda örnek kullanımlar gösterilmiştir:
  
  /* Define configASSERT() to call vAssertCalled() if the assertion fails.  The assertion
  has failed if the value of the parameter passed into configASSERT() equals zero. */
  #define configASSERT( ( x ) )     if( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )
  
  /* Define configASSERT() to disable interrupts and sit in a loop. */
  #define configASSERT( ( x ) )     if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }
  
  configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS -> Yalnızca FreeRTOS MPU'su tarafından kullanılır.
  Eğer 1 olarak ayarlanmışsa kodlayıcı  uygulamayı yazanın priveleged modda çalıştırmaya ihtiyaç duyacağı fonksiyonları 
  implemete edilebilmesi için "application_defined_privileged_functions.h" isminde bir başlık dosyası sağlamalıdır.
  Bu bir başlık dosyası olmasına rağmen fonksiyonların sadece prototiplerini içermemelidir. Aynı zamanda implementasyonlarını da
  içermelidir.
  "application_defined_privileged_functions.h" başlık dosyasında implemente edilen fonksiyonlar 
  prvRaisePrivilege() fonksiyonunu ve portRESET_PRIVILEGE() makrosunu kullanarak işlemcinin privelege state'ini kaydetmeli ve tekrar yüklemelidir.
  Örneğin eğer kütüphanenin sağlamış olduğu kodu yazanın kontrolü dışında RAM'e ulaşan bir print fonksiyonu varsa ve bundan dolayı bu fonksiyon 
  hafıza korumalı kullanıcı modundaki task'a yerleştirilemiyorsa, aşağıdaki kod örneği kullanılarak bu print fonksiyonu priveleged fonksiyonun
  içerisine enkapsüle edilebilir.
  void MPU_debug_printf( const char *pcMessage )
  {
    /* State the privilege level of the processor when the function was called. */
    BaseType_t xRunningPrivileged = prvRaisePrivilege();

    /* Call the library function, which now has access to all RAM. */
    debug_printf( pcMessage );

    /* Reset the processor privilege level to its original value. */
    portRESET_PRIVILEGE( xRunningPrivileged );
  }
  
  Bu teknik hafıza korumadan kaçınmak için yalnızca development esnasında kullanılmalıdır, deployment esnasında değil.
  
  INCLUDE Parameters -> INCLUDE ile başlayan makrolar uygulamanız tarafından sağlanmayan real time kernel'in bu komponentlerinin derlemenizin 
  dışında kalmasını izin vermektedir. Bu durum RTOS'un sizin özel gömülü uygulamanızın ihtiyaç duyduğu RAM ve ROM'u kullanmamasını 
  sağlamaktadır.
  Her makro şu şekilde bir fomra sahiptir...
  INCLUDE_FunctionName
  ..buradaki FunctionName ibaresi opsiyonel olarak exclude edilebilen API fonksiyonunu (yada bir kısım fonksiyon setini) belirtmektedir.
  Include için 1 olarak exclude için 0 olarak ayarlanmalıdır.
  Örneğin vTaskDelete() API fonksiyonunu include etmek için:
  #define INCLUDE_vTaskDelete    1
  derlemeden exclude etmek için ise:
  #define INCLUDE_vTaskDelete    0 
  kullanılır.
  
  
  HAFIZA YÖNETİMİ:
  RTOS kerneli her task, queue, mutex, software timer, semafor yada event group yaratıldığında RAM'e ihtiyaç duymaktadır.
  RAM RTOS heap'inden otomatik olarak RTOS API'si nesne yaratma fonksiyonları ile otomatik olarak yada uygulamayı kodlayan 
  tarafından yaratılabilmektedir. 
  FreeRTOS portable katmanında API hafıza tahsisini icra etmektedir. malloc ve free yerine pvPortMalloc() ve vPortFree() 
  kullanılmaktadır. 
  RTOS Kaynak Kodu İçindeki hafıza yerleşimi uygulamaları:
  Source/Portable/MemMang dizisi altında bulunan heap_1.c, heap_2.c, heap_3.c, heap_4.c ve heap_5.c dosyaları ile hafıza yerleşim
  uygulama şemaları bulumaktadır. Bunlardan heap_5.c aşağıda açıklanmaktadır.
  
  heap_5.c: Bu şema heap_4.c gibi gibi serbest hafıza alanlarını bütünleştirmekte, fakat farklı olarak komşu olmayan 
  hafıza alanlarını da bütünleştirmektedir.
  Heap_5 vPortHeapDefineRegions() çağırılarak ilklendirilir, ve vPortDefineHeapRegions() çalıştıktan sonra kullanılamaz.
  RTOS objesinin yaratılması(task, queue, semaphore v.b.) dolaylı olarak pvPortMalloc() fonksiyonunu çağıracaktır bundan dolayı
  heap_5 kullanılırken böyle bir nesne yaratılmadan önce vPortDefineHeapRegions()'ın çağırılması esas teşkil etmektedir.
  vPortDefineHeapRegions() tek bir parametre almaktadır. 
  RTOS nesnesi tek bir parametre alır. Bu parametre HeapRegion_t structure'ı türünden elemanlardan oluşan bir dizidir.
  
  typedef struct HeapRegion
  {
      /* Start address of a block of memory that will be part of the heap.*/
      uint8_t *pucStartAddress;

      /* Size of the block of memory. */
      size_t xSizeInBytes;
  } HeapRegion_t;

  /* Allocate two blocks of RAM for use by the heap.  The first is a block of
  0x10000 bytes starting from address 0x80000000, and the second a block of
  0xa0000 bytes starting from address 0x90000000.  The block starting at
  0x80000000 has the lower start address so appears in the array fist. */
  const HeapRegion_t xHeapRegions[] =
  {
      { ( uint8_t * ) 0x80000000UL, 0x10000 },
      { ( uint8_t * ) 0x90000000UL, 0xa0000 },
      { NULL, 0 } /* Terminates the array. */
  };

  /* Pass the array into vPortDefineHeapRegions(). */
  vPortDefineHeapRegions( xHeapRegions );
  
  vPortDefineHeapRegions'a parametre olarak geçen bu dizi NULL ile sonlandırılmaktadır, ve hafıza alanları düşük adresten yüksek adrese 
  doğru adres sırasıyla bulunmalıdır.
  xPortGetFreeHeapSize() API fonksiyonu çağırıldığında yerleştirilmemiş olarak kalmış heap hafıza alanlarını dönmekte, ve 
  xPortGetMinimumEverFreeHeapSize() fonksiyonu enküçük boştaki heap alanını FreeRTOS uygulaması boot edildiğinde dönmektedir.
  Hiç bir fonksiyon yelrleştirilmemiş küçük bloklara segmente edilmiş heap alanları hakkında bilgi vermemektedir.
  
  STACK OVERFLOW TESPİTİ:
  Stack kullanımı ve Stack Overflow Kontrolü: Her task kendi stack'ını sürdürür. Eğer task xTaskCreate() kullanarak yaratılmışsa
  task'in stack'i olarak kullanılan hafıza alanı FreeRTOS heap'ten otomatik olarak atanır, ve xTaskCreate() API fonksiyonuna geçen
  parametre ile boyutu belirtilmektedir.
  Eğer task xTaskCreateStatic() kullanılarak yaratılıyorsa task'in stack'i olarak kullanılan hafıza alanı uygulamayı kodlayan 
  tarafından yaratılır. Stack overflow genel olarak görülen bir uygulama kararsız çalışma sebeplerindendir.
  Bu duruma çözüm sunmak amacıyla FreeRTOS iki opsiyonel mekanizma sunmuştur. Bunlardan biri configCHECK_FOR_STACK_OVERFLOW konfigürasyon
  sabitidir.
  Bu opsiyon sadece hafıza haritası segmente edilmediği durumda geçerlidir. Ayrıca bazı mikroişlemciler RTOS kernel overflow kontrol oluşabilme durumundan
  önce bir stack corruption'ınına cevaben bit hata yada istisna durumu oluşturabilirler. Uygulama eğer configCHECK_FOR_STACK_OVERFLOW 0'a ayarlanmamışsa 
  bir stack overflow hook fonksiyonu oluşturmalıdır. Hook fonksiyonu vApplicationStackOverflowHook() olarak adlandırılmalı ve aşağıdaki prototipe
  sahip olmalıdır:
    voido vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName ); 
  xTask ve pcTaskName parametreleri amaçlanan taskın handle ve isim hook fonksiyonunu geçmektedir.
  Buna rağmen dikkat edilmelidir ki bu parametrelerin kendileri de overflow'un ciddiyetine göre pxCurrentTCB değişkeni 
  direk olarak kontrol edildiğinde overflow olabilirler.
  Stackoverflow kontrolü context switch overhead'ine neden olabilmektedir. Bu sebeple sadece geliştirme yada test fazında icra edilmelidir.
  
    Stack Overflow Tespiti - Method 1 
    Olası olarak  RTOS çekirdeği task çalışan state'in dışına çıktığında stack en büyük değerini aşacaktır. Bu notada RTOS çekirdeği işlemci
    stack pointerının geçerli stack alanında kalıp kalmadığını kontrol eder. Eğer stack pointerı geçerli stack alanının dışında bir değer içeriyorsa
    stack overflow hook fonksiyonu çağırılır.
    Bu method hızlıdır fakat ütün stack overflow'ların tespit edilmesini garanti etmez.
    Bu methodu kullanmak için configCHECK_FOR_STACK_OVERFLOW 1 olarak ayarlanmalıdır.
    Stack Overflow Tespiti - Method 2
    Bir task yaratıldığında işk olarak bilinen bir değerle doldurulur. Ne zaman task çalışan state'in dışına çıkarsa RTOS kernel'i son 
    16 byte'ı başta belirlediğimiz bilinen değerlerin task yada interrupt aktivitesi tarafından overwrite edilip edilmediğini kontrol eder.
    
    Bu method method 1'den daha az etkindir fakat yine de oldukça hızlıdır.
    Bu method tek başına kullanılmaz. Method 1 ile kombine bir şekilde kullanılır. Bu kullanım şekli için configCHECK_FOR_STACK_OVERFLOW 2
    olarak ayarlanır.
    
  TASK YARATMA:
    TaskHandle_t task'ların referense edildiği tiptir. task.h başlık dosyasında bulunmaktadır. Örneğin, xTaskCreate çağırıldğında bir TaskHandle_t tipinde değiken dönmektedir ki 
    bu değişken vTaskDelete'te task'ın silnmesi için parametre olarak kullanılabilmektedir.
    Modülller:
      xTaskCreate ve xTaskCreateStatic: task.h başlık dosyasında bulunmaktadır. Aşağıda nasıl kullnıldığı gösterilmektedir:
        BaseType_t xTaskCreate(    TaskFunction_t pvTaskCode,
                            const char * const pcName,
                            unsigned short usStackDepth,
                            void *pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t *pxCreatedTask
                          );
       Yeni bir task yaratır ve bu taskı çalışmaya hazır task'ların listesine eklemektedir.
       configSUPPORT_DYNAMIC_ALLOCATION FreeRTOSConfig.h başlık dosyasında 1 olarak ayarlanmalıdır, yada tanımsız bırakılır(1 olarak 
       ayarlandığı durumdaki gibi davranır), bu RTOS API fonksiyonu için erişilebilirdir.

       Her task task'ın durumunu tutacak RAM'e ihtiyaç duymaktadır, ve task tarafından stack'i olarak kullanır.
       Eğer task xTaskCreate() kullanılarak yaratılırsa ihtiyaç duyulan RAM otomatik olarak FreeRTOS heap'inden yerleştirilir.
       Eğer task xTaskCreateStatic() kullanılarak yaratılırsa, RAM programı kodlayan tarafından sağlanır, bunndan dolayı statik yerleşim
       derleme zamanında yapılır. Static vs Dynamic Allocation sayfasından daha detaylı bilgi edilebilir.
       Eğer FreeRTOS - MPU kullanılıyorsa xTaskCreate() yerine xTaskCreateResrticted() kullanılması tavsiye edilmektedir.
       Parameteler:
        pvTaskCode: task giriş(entry) fonksiyonuna göstericidir (task'ı uygulayan task'ın ismi gibi, aşağıdaki örnekte gösterilmektedir).
        Tasklar normalde sonsuz döngü olarak uygulanır, ve asla uygulandıkları fonksiyonda geri dönüş ve çıkış girişiminde bulunmazlar.
        Bununla birlikte kendilerini silebilirler.
        pcName: Task için tanımlayıcı bir isimdir. Bu temel olarak debugging'i kolaylaştırmak için kullanılır fakat aynı zamanda task handle
        elde etmek için de kullanilabilmektedir.
        Task'ın isminin maksimum uzunluğu FreeRTOSConfig.h başlık dosyasındaki 
        configMAX_TASK_NAME_LEN parametresi kullanılarak da ayarlanılabilir.
        usStackDepth: task stack'inin kullanımı için yerleştirilecek word sayısını(byte değil) belirtmek için kullanılır. Örneğin, eğer
        task stack'i 16 bit genişliğinde ise ve usStackDepth 100 ise, task'in stack'inin kullanımı için 200 byte yerleştirilir. 
        Diğer bir örnek olarak verilebilecek durum, eğer stack genişliği 32 bit ise ve usStackDepth 400 ise task stack'inin yerleştirilen 
        alanı 1600 byte'dır.
        stack genişliği ile Stack derinliğinin çarpımı size_t tipinde değişkenin alabileceği maksimum değeri aşmamalıdır.
        FAQ'a bakınız. Stack ne kadar büyük olmalıdır.
        pvParameters: Yaratılan task'a task'ın parametresi olarak gönderilen değerdir.
        Eğer pvParameters bir değişkenin adresi ise yaratılan task çalıştığında bu değişkenin hali hazırda belirlenmiş olmalıdır - bundan
        dolayı bir stack değişkeninin adresi geçilmesi geçerli değildir.
        uxPriority: Yaratılan taskın çalışacağı priority'dir.
        MPU desteği olan sistemlerde opsiyonel olarak task uxPriority'nin  portPRIVILEGE_BIT'i set edilerek privileged(system) modunda task
        yaratılabilmektedir( 2 | portPRIVILEGE_BIT ).
        pxCreatedTask: xTaskCreate() fonksiyonu kullanılarak yaratılan task'a handle göndermek için kullanılır. Opsiyoneldir ve NULL olarak 
        ayarlanabilir.
        Dönüş: 
          Eğer task başarılı bir şekilde yaratıldıysa pdPass geri döner. Aksi halde errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY geri dönmektedir.

        Örnek Kullanımı: 
          /* Task to be created. */
          void vTaskCode( void * pvParameters )
          {
              /* The parameter value is expected to be 1 as 1 is passed in the
              pvParameters value in the call to xTaskCreate() below. 
              configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

              for( ;; )
              {
                  /* Task code goes here. */
              }
          }

          /* Function that creates a task. */
          void vOtherFunction( void )
          {
          BaseType_t xReturned;
          TaskHandle_t xHandle = NULL;

              /* Create the task, storing the handle. */
              xReturned = xTaskCreate(
                              vTaskCode,       /* Function that implements the task. */
                              "NAME",          /* Text name for the task. */
                              STACK_SIZE,      /* Stack size in words, not bytes. */
                              ( void * ) 1,    /* Parameter passed into the task. */
                              tskIDLE_PRIORITY,/* Priority at which the task is created. */
                              &xHandle );      /* Used to pass out the created task's handle. */

              if( xReturned == pdPASS )
              {
                  /* The task was created.  Use the task's handle to delete the task. */
                  vTaskDelete( xHandle );
              }
          }
        
     vTaskDelete: task.h başlık dosyasında bulunmaktadır. Bu fonksiyonun erişilebilir olması için INCLUDE_vTaskDelete 1 olarak tanımlanmak
     zorundadır.
     Daha çok bilgi için RTOS Configuration dokümanına bakınız.
     RTOS kernel yönetiminden bir taskı siliniz. Silinmiş olan task bütün hazır, blocked, suspended ve event list'ten silinecektir.
     Not: Idle task'ı tasktan silinnmiş olan RTOS kernel atanmış hafızayı serbest bırakmaktan sorumludur. Bu sebeple eğer uygulama vTaskDelete()
     fonksiyonunu çağırmış ise idle task mikroişlemci processing time'dan yoksun bırakılmamalıdır.Task code'u tarafından atanmış hafıza otomatik 
     olarak serbest bırakılmaz, task silinmeden önce serbest bırakılmalıdır.
     Demo uygulamasındaki vTaskDelete() fınksiyonundan faydalanan death.c doyasına bakınız.
     Parametreler: xTask. Silinecek taskın handle'ı. NULL geçmek çapırılan task'ın silinmesine neden olacaktır.
     Örnek Kullanım:
       void vOtherFunction( void )
       {
       TaskHandle_t xHandle = NULL;

           // Create the task, storing the handle.
           xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );

           // Use the handle to delete the task.
           if( xHandle != NULL )
           {
               vTaskDelete( xHandle );
           }
       }
       
  TASK KONTROL:
    vTaskDelay: task.h başlık dosyasında yer almaktadır. Aşağıda görüldüğü şekilde bir kullanımı vardır:
      void vTaskDelay( const TickType_t xTicksToDelay );
    Bu fonksiyonun erişilebilir olması için INCLUDE_vTaskDelay 1 olarak ayarlanmalıdır. Daha çok bilgi için RTOS Configuration 
    dokümanına bakınız.
    Taska belirtilen tick sayısı miktarında bir gecikme vermektedir.Taskın blocked durumda kalacağı güncel zaman değeri tick rate'e 
    bağlıdır.
    portTICK_PERIOD_MS sabiti tick rate'in gerçek değerini hesaplamak için tick period çözünürlüğü ile bürlikte kullanılabilir.
    Parametre:
      xTicksToDelay: Çağırılan taskın bloklanacağı tick periyodu cinsinden zaman miktarını belirtmektedir.
    Örnek Kullanımı:
      void vTaskFunction( void * pvParameters )
      {
         /* Block for 500ms. */
         const TickType_t xDelay = 500 / portTICK_PERIOD_MS;

             for( ;; )
             {
                 /* Simply toggle the LED every 500ms, blocking between each toggle. */
                 vToggleLED();
                 vTaskDelay( xDelay );
             }
      }

    vTaskDelayUntil: task.h başlık dosyasında bulunmaktadır. Aşağıdaki gibi bir kullanımı vardır:
      void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );
    Bu fonksiyonun erişilebilir olmsdı için INCLUDE_vTaskDelayUntil 1 olarak ayarlanmalıdır.
    Daha çok bilgi için RTOS Configuration dokümanını inceleyiniz.
    Task'ı belirlenen bir zamana kadar geciktirir. Bu fonksiyon sabit bir çalışma frekansı sağlamak için
    periyodik tasklar tarafından kullanılabilir. Bu fonksiyon vTaskDelay()'dan önemli bir açıdan farklıdır:
    vTaskDelay() çağırıldığı zamana göre taskın unblock edileceği zamanı belirtmektedir, oysaki vTaskDelayUntil()
    fonksiyonu unblock edilecek zamanı kesin bir şekilde belirtmektedir.
    Parameteleri:
     pxPreviousWakeTime: Task'ın son olarak unblock olduğu zamanı tutmaktadır. Kullanım olarak taskın içerisinde 
      vTaskDelayUntil() fonksiyonuna gönderilmeden önce şu anki zamanı xTaskTickGetCount() ile göndeririz. Bunu müteakip 
      vTaskDelayUntil() fonksiyonuna parametre olarak gönderilir ve bu fonksiyon içerisinde güncellenir. 
     xTimeIncrement: Zaman periyodu saykılıdır. Task  (*pxPreviousWakeTime + xTimeIncrement) zamanında unblock edilir.  
     Bu parametre ile task sabit bir dahili periyotta çalışır.
     
    Örnek Kullanım:
       // Perform an action every 10 ticks.
       void vTaskFunction( void * pvParameters )
       {
       TickType_t xLastWakeTime;
       const TickType_t xFrequency = 10;

           // Initialise the xLastWakeTime variable with the current time.
           xLastWakeTime = xTaskGetTickCount();

           for( ;; )
           {
               // Wait for the next cycle.
               vTaskDelayUntil( &xLastWakeTime, xFrequency );

               // Perform action here.
           }
       }
      
  uxTaskPriorityGet: task.h basşlık dosyasında bulunmaktadır. Aşağıdaki şekilde kullanılmaktadır:
    UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );
  Bu fonksiyonun erişilebilir olması için INCLUDE_uxTaskPriorityGet 'nin 1 olarak tanımlanması gerekir. RTOS konfigürasyon dokümanını
  inceleyiniz.
  Task'ın priority'sini elde etmek için kullanılır.
  Parametreler: 
    xTask: İstemde bulunulmuş task'ın handle'ıdır.
  Dönüş değeri:
    xTask'ın priority'sidir.
   
   Örnek Kullanım:  
    void vAFunction( void )
   {
   TaskHandle_t xHandle;

       // Create a task, storing the handle.
       xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );

       // ...

       // Use the handle to obtain the priority of the created task.
       // It was created with tskIDLE_PRIORITY, but may have changed
       // it itself.
       if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
       {
           // The task has changed its priority.
       }

       // ...

       // Is our priority higher than the created task?
       if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
       {
           // Our priority (obtained using NULL handle) is higher.
       }
   }
   
   vTaskPrioritySet: task.h başlık dosyasında bulunmaktadır. Aşağıdaki gibi kullanılmaktadır:
    void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );
   Bu fonksiyonun erişilebilir olabilmesi için INCLUDE_vTaskPrioritySet 1 olarak ayarlanmalıdır. Daha çok bilgi için RTOS
   Configuration dokümanını inceleyiniz.
   Herhangi bir task'ın priority'sini ayarlamak için kullanılmaktadır.
   Eğer priority halihazırda çalışan task'tan daha yüksek seviyede ayarlanırsa context switch fonksiyon geri dönüşünden önce olur.
   Parametreler: 
    xTask: Priority'sinin set edileceği task'ı tutmaktadır. Eğer NULL değeri tutulmuşsa bir önceki priority'si set edilen task'ın
    priority'sini günceller.
    uxNewPriority: Priority'si ayarlanacak task'ın yeni ayarlanan priority değeridir.
    Örnek Kullanımı:
       void vAFunction( void )
       {
       TaskHandle_t xHandle;

           // Create a task, storing the handle.
           xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );

           // ...

           // Use the handle to raise the priority of the created task.
           vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );

           // ...

           // Use a NULL handle to raise our priority to the same value.
           vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
       }
     
    vTaskSuspend: task.h başlık dosyasında yer almaktadır. Örnek kullanımı aşağıda gösterilmiştir:
      void vTaskSuspend( TaskHandle_t xTaskToSuspend );
    Bu fonksiyona erişilebilmesi için INCLUDE_vTaskSuspend 1 olarak ayarlanmalıdır. Daha fazla bilgi için RTOS Configuration 
    dokümanını inceleyiniz.
    Herhangi bir taskı askıya alabilir(suspend). Bir task askıya alondığında priority'si ne olursa olsun mikrokontrolör'ün 
    çalışma(processing) zamanını asla almaz.
    vTaskSuspend'in çağrılıması biriktirici değildir - örneğin vTaskSuspend()'in aynı task'ta 2 kere çağırılması durumunda 
    askıda olan bu taskın tekrar çalışmaya başlaması için vTaskResume()'in 1 kere çağırılması yeterlidir. 2 kere çağırılmasına gerek
    yoktur.
    Parametreler: 
      xTaskToSuspend: Askıda olan taskı tutan parametredir. NULL değerini tutması durumunda üzerinde önceden çalışılmakta olan
    task'ın yine askıya alınmasını sağlamaktadır.
    Örnek Kullanım:
      void vAFunction( void )
     {
     TaskHandle_t xHandle;

         // Create a task, storing the handle.
         xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );

         // ...

         // Use the handle to suspend the created task.
         vTaskSuspend( xHandle );

         // ...

         // The created task will not run during this period, unless
         // another task calls vTaskResume( xHandle ).

         //...

         // Suspend ourselves.
         vTaskSuspend( NULL );

         // We cannot get here unless another task calls vTaskResume
         // with our handle as the parameter.
     }
     
   vTaskResume: task.h başlık dosyasında bulunmaktadır. Örnek kullanımı aşağıda gösterilmiştir:
    void vTaskResume( TaskHandle_t xTaskToResume );
   Bu fonksiyonun erişilebilir olması için INCLUDE_vTaskSuspend'in 1 olarak tanımlanması gerekir. Daha fazla bilgi için 
   RTOS Configuration dokümanını inceleyiniz.
   Askıya alınmış bir task'ın devam etmesini sağlamaktadır.
   Bir yada birden daha fazla vTaskSuspended() fonksiyonu ile askıya alınmış bir taskın tekrar çalışmaya başlaması için 
   bir kere vTaskResume() fonksiyonunun çağırılması yeterelidir.
   Parametreler: 
    xTaskToResume: Okunmuş olan taskı tutmaktadır.
   Örnek Kullanımı: 
   
     void vAFunction( void )
     {
     TaskHandle_t xHandle;

         // Create a task, storing the handle.
         xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );

         // ...

         // Use the handle to suspend the created task.
         vTaskSuspend( xHandle );

         // ...

         // The created task will not run during this period, unless
         // another task calls vTaskResume( xHandle ).

         //...

         // Resume the suspended task ourselves.
         vTaskResume( xHandle );

         // The created task will once again get microcontroller processing
         // time in accordance with its priority within the system.
     }
   xTaskResumeFromISR: task.h başlık dosyasında bulunmaktadır. Örnek kullanımı aşağıda verilmiştir:
    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume );
   Bu fonksiyonun erişilebilir olaması için INCLUDE_vTaskSuspend ve INCLUDE_xTaskResumeFromISR 1 olarak ayarlanmalıdır.Daha fazla
   bilgi için RTOS Configuration dokümanına bakınız.
   ISR içerisinde çağırılabilen askıda olan bir task'ın tekrar çağırılmasını sağlayan bir fonksiyondur.
   Bir yada birden fazla vTaskSuspend() ile askıya alınmış olan bit taskın takrar çalışması için 1 kere vTaskResumeFromISR() fonksiyonunun
   çağırılması yeterlidir.
   Bu fonksiyon genelde tehlikeli bir fonksiyon olarak görülür çünkü çalışması latch edilmiş değildir. 
   
   Bu nedenle, görevin askıya alınmasından önce kesmenin gelebileceği ve dolayısıyla kesmenin kaybolduğu bir task'ı,
   bir kesme ile senkronize etmek için kesinlikle kullanılmamalıdır.
   Semafor kullanımı, yada direct to task notification'ın tercih edilmesi bu durumdan kaçınılmasını sağlayacaktır.
   Parametreler: 
    xTaskToResume: Okunan task'ın tutlmasını sağlamaktadır.
   Geri Dönüş Değerleri: 
    Eğer devam eden task context switch içerisinde sonuç vermesi gerekiyorsa pdTRUE, aksi halde pdFALSE geri dönüş değeri olacaktır.
    Bu geri dönüş değeri ISR tarafından müteakip ISR tarafından context switch'e gerek duyulup duyulmadığını belirlemek için kullanılacaktır.
   Örnek kullanım aşağıda gösteriilmiştir:
    TaskHandle_t xHandle;

     void vAFunction( void )
     {
         // Create a task, storing the handle.
         xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );

         // ... Rest of code.
     }

     void vTaskCode( void *pvParameters )
     {
         // The task being suspended and resumed.
         for( ;; )
         {
             // ... Perform some function here.

             // The task suspends itself.
             vTaskSuspend( NULL );

             // The task is now suspended, so will not reach here until the ISR resumes it.
         }
     }


     void vAnExampleISR( void )
     {
     BaseType_t xYieldRequired;

         // Resume the suspended task.
         xYieldRequired = xTaskResumeFromISR( xHandle );

         if( xYieldRequired == pdTRUE )
         {
             // We should switch context so the ISR returns to a different task.
             // NOTE:  How this is done depends on the port you are using.  Check
             // the documentation and examples for your port.
             portYIELD_FROM_ISR();
         }
     }
  
  xTaskAbortDelay: task.h başlık dosyasında bulunmaktadır. Örnek kullanımı aşağıda verilmiştir:
    BaseType_t xTaskAbortDelay( TaskHandle_t xTask );
  Blocked State'ten ayrılınması için zorlar ve blocked state'teki beklenen event gerçekleşmemiş ve belirtilen 
  timeout aşılmamış olsa bile Ready State'e sokar.
  Bu fonksiyonun erişilebilmesi için INCLUDE_xTaskAbortDelay  1 olarak ayarlanmalıdır. Daha fazla bilgi için RTOS Configuration
  dokümanına bakınız.
  Parametreler: 
    xTask: Blocked State'ten çıkması için zorlanan task'ı tutmaktadır.
    Bir task handle yaratımının elde edilmesi için xTaskCreate() fonksiyonu kulanılır ve xTaskCreate() fonksiyonunun
    pxCreatedTask parametresinden faydalanılır, yada xTaskCreateStatic() kullanılarak task yaratılır ve geri dönüş değeri 
    kaydedilir, yada xTaskGetHandle() fonksiyonu çağırımındaki task'ın ismi kullanılır.
  Geri Dönüş Değerleri: Eğer xTask tarafından referans edilen task Blocked State'de değilse pdFAIL geri döner. Aksi halde 
  pdPASS geri döner.
                                                RTOS KERNEL CONTROL
  taskYIELD:
  Başka bir taska context switch yapılması için
  talepte bulunmak için kullanılıyor.
  Fakat taskYIELD()'i çağıran fonksiyondan daha yüksek veya eşit
  Priorityli task yoksa RTOS scheduler tekrar taskYIELDi çağıran 
  Taski çalıştırır.
  Eğer configUSEPREEMPTION 1 olarak ayarlanmışsa RTOS scheduler her zaman
  En yüksek priorityli taskı çalıştırır. Böyle bir durumda taskYIELD asla
  daha yüksek priorityli bir taska context switch yapamaz
  
  taskDISABLE_INTERRUPTS: Eğer portun kullanımı configMAX_SYSCALL_INTERRUPT_PRIORITY
   kullanımını destekliyorsa  (yada configMAX_API_CALL_INTERRUPT_PRIORITY)
   taskDISABLE_INTERRUPTS ya bütün interruptları etkisizleştirecek
   yada configMAX_SYSCALL_INTERRUPT_PRIORITY nin daha üstündeki seviyedeki interruptları
   maskeler (etkisizleştirir).
   taskDISABLE_INTERRUPTS'ın port için kullanım uygulamalarını kontrol ediniz.
   Eğer kullanımdaki port configMAX_SYSCALL_INTERRUPT_PRIORITY  sabitini desteklemiyorsa
   taskDISABLE_INTERRUPTS global olarak bütün maskable interrupt(kesme) ları etkisizleştirir(disable).

   Normalde bu makro direk olarak çağırılmamalı ve onun yerine
   and taskENTER_CRITICAL() ve taskEXIT_CRITICAL() kullanılmalıdır.
 
 taskENABLE_INTERRUPTS:
 
 Mikrokontrölor interruptlarinı etkinleştirmek için kullanılır.
 Normalde bu makro direk olarak çağırılmamalı ve onun yerine
 and taskENTER_CRITICAL() ve taskEXIT_CRITICAL() kullanılmalıdır.
 
 taskENTER_CRITICAL() 
 taskEXIT_CRITICAL():
 Critical section'lara taskENTER_CRITICAL çağırılarak girilir ve 
 bilahere taskEXIT_CRITICAL() çağırılarak çıkılır.
 taskENTER_CRITICAL() ve taskEXIT_CRITICAL() global olarak yada belirlenmiş
 bir seviyedeki interrupt priority'sinin üstündeki interruptlari etkisizleştirerek çalışan
 basit bir critical section uygulaması sağlamaktadir.
 Interruptları etkisizleştirmeden bir critical section yaratılması hakkında
 Bilgi almak için vTaskSuspendAll() RTOS API fonksiyonuna bakınız.
 
 Eğer kullanılmakta olan FreeRTOS portu configMAX_SYSCALL_INTERRUPT_PRIORITY (configMAX_API_CALL_INTERRUPT_PRIORITY olarak da çağırılır)
 kernel konfigürasyon sabitinden faydalanmıyorsa, taskENTER_CRITICAL() i çağırmak interruptlari global olarak
 etkisizleştirir.
 
 Eğer kullanılan FreeRTOS portu configMAX_SYSCALL_INTERRUPT_PRIORITY'ten faydalanıyorsa, sonrasında 
 taskENTER_CRITICAL() çağırılmasıyla configMAX_SYSCALL_INTERRUPT_PRIORITY tarafından ayarlanan interrupt priority'sinin
 Seviyesindeki ve bu seviyenin altındaki priority deki interruptlar etkisizleştirilecek, daha yüksek priority seviyeli interruptlar
 etkinleştirilecektir.
 Preemptive context switch'ler sadece interrupt'ların içinde olur, bundan dolayı interruptlar etkisizleştirildiğinde oluşmayacaklardır.
 Bundan dolayı taskENTER_CRITICAL'ı çağırmış olan task direk olarak
 block yada yield(critical section'ın içerisinden olmaması gerekir) eylemlerini icra etmeye kalkışmadıkça, critical section sona erene kadar
 running state'te kalmayı garanti eder.
 taskENTER_CRITICAL() ve taskEXIT_CRITICAL() çağırılması nest eyleminde çalışacak şekilde tasarlanmıştır.
 Bundan dolayı bir critical section yalnız öncesinde bir 
 taskENTER_CRITICAL() çağırılmış bir çalışmış olan taskEXIT_CRITICAL() çağırıldığında olmaktadır.
 Critical Sections çok kısa tutulcaktır, aksi halde interrupt cevap sürelerini olumsuz olarak etkileyeceklerdir.
 Her bir taskENTER_CRITICAL() taskEXIT_CRITICAL() ile yakın olarak birlikte ele alınmalıdır.
 FreeRTOS API fonksiyonları critical section içerisinden çağırılmamalıdır.
 taskENTER_CRITICAL() ve taskEXIT_CRITICAL() interrupt service routine(ISR)'den çağırılmamalıdır - interrupt güvenliği için
 bu fonksiyonların muadili olan  taskENTER_CRITICAL_FROM_ISR() ve taskEXIT_CRITICAL_FROM_ISR() fonksiyonlarına bakınız.
 Parametreleri: Yoktur.
 Geri Dönüş Değerleri: Yoktur.
 
 Örnek Kullanımı: 
 /* A function that makes use of a critical section. */
  void vDemoFunction( void )
  {
      /* Enter the critical section.  In this example, this function is itself called
      from within a critical section, so entering this critical section will result
      in a nesting depth of 2. */
      taskENTER_CRITICAL();

      /* Perform the action that is being protected by the critical section here. */

      /* Exit the critical section.  In this example, this function is itself called
      from a critical section, so this call to taskEXIT_CRITICAL() will decrement the
      nesting count by one, but not result in interrupts becoming enabled. */
      taskEXIT_CRITICAL();
  }

  /* A task that calls vDemoFunction() from within a critical section. */
  void vTask1( void * pvParameters )
  {
      for( ;; )
      {
          /* Perform some functionality here. */

          /* Call taskENTER_CRITICAL() to create a critical section. */
          taskENTER_CRITICAL();


          /* Execute the code that requires the critical section here. */


          /* Calls to taskENTER_CRITICAL() can be nested so it is safe to call a
          function that includes its own calls to taskENTER_CRITICAL() and
          taskEXIT_CRITICAL(). */
          vDemoFunction();

          /* The operation that required the critical section is complete so exit the
          critical section.  After this call to taskEXIT_CRITICAL(), the nesting depth
          will be zero, so interrupts will have been re-enabled. */
          taskEXIT_CRITICAL();
      }
  }
 
 taskENTER_CRITICAL_FROM_ISR() 
 taskEXIT_CRITICAL_FROM_ISR():
 Örnek kullanımı aşağıda gösterilmiştir:  
  UBaseType_t taskENTER_CRITICAL_FROM_ISR( void );
  void taskEXIT_CRITICAL_FROM_ISR( UBaseType_t uxSavedInterruptStatus );
  
  taskENTER_CRITICAL() ve taskEXIT_CRITICAL()'nin ISR'de kullanılabilen versiyonlarıdır.
  ISR'da critical section'a taskENTER_CRITICAL_FROM_ISR() fonksiyonu çağırılarak ile girmekte ve buna müteakip taskEXIT_CRITICAL_FROM_ISR()
  fonksiyonu ile critical section ile çıkmaktadır.

  The taskENTER_CRITICAL_FROM_ISR() ve taskEXIT_CRITICAL_FROM_ISR() makroları interruptları global olarak yada 
  belirli bir priority seviyesinin üstündeki interruptları etkisizleştirerek basit bir critical section uygulaması sağlamaktadır.
  Eğer kullanılmakta olan FreeRTOS port'u nesting interrupt'ı destekliyorsa, taskENTER_CRITICAL_FROM_ISR() 
  configMAX_SYSCALL_INTERRUPT_PRIORITY (yada configMAX_API_CALL_INTERRUPT_PRIORITY) kernel konfigürasyon sabiti ile ayarlanan 
  interrupt priority'sinin seviyesindeki ve bu seviyenin altındaki seviyelerdeki interrupt'ları etkisizleştirecek, 
  diğer bütün interrupt priority'lerini etkinleştirecektir.
  taskENTER_CRITICAL_FROM_ISR() ve taskEXIT_CRITICAL_FROM_ISR() çağırılması nest yapıdadır, 
  fakat bu makroların nasıl kullanılacaklarının anlamsallıkları(semantics - semantikler) 
  taskENTER_CRITICAL() ve taskEXIT_CRITICAL() eşdeğerlerinden farklıdır.
  FreeRTOS API fonksiyonları critical section içerisinden çağırılmalıdır.
  Parametreler: 
    taskEXIT_CRITICAL_FROM_ISR() uxSavedinterruptStatus'ı yalnızca parametre olarak almalıdır. uxSavedinterruptStatus parametesinin değeri
    taskENTER_CRITICAL_FROM_ISR() fonksiyonunun geri dönüş değerini almalıdır.
    taskENTER_CRITICAL_FROM_ISR() herhangi bir parametre almaz.
    
    Geri Dönüş Değerleri:
    taskENTER_CRITICAL_FROM_ISR() makronun çağırılmasından önceki interrupt mask state'i geri dönmektedir.  
    taskENTER_CRITICAL_FROM_ISR() makrosunun geri dönüş değeri taskENTER_CRITICAL_FROM_ISR()'nin eşi olan taskEXIT_CRITICAL_FROM_ISR()
    makrosunun uxSavedInterruptStatus parametresinin değeri olarak kullanılmalıdır.
    taskEXIT_CRITICAL_FROM_ISR() herhangi bir değer geri dönmez.
    
    Örnek Kullanım: 
    
    /* A function called from an ISR. */
    void vDemoFunction( void )
    {
    UBaseType_t uxSavedInterruptStatus;

        /* Enter the critical section.  In this example, this function is itself called from
        within a critical section, so entering this critical section will result in a nesting
        depth of 2. Save the value returned by taskENTER_CRITICAL_FROM_ISR() into a local
        stack variable so it can be passed into taskEXIT_CRITICAL_FROM_ISR(). */
        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();

        /* Perform the action that is being protected by the critical section here. */

        /* Exit the critical section.  In this example, this function is itself called from a
        critical section, so interrupts will have already been disabled before a value was
        stored in uxSavedInterruptStatus, and therefore passing uxSavedInterruptStatus into
        taskEXIT_CRITICAL_FROM_ISR() will not result in interrupts being re-enabled. */
        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
    }

    /* A task that calls vDemoFunction() from within an interrupt service routine. */
    void vDemoISR( void )
    {
    UBaseType_t uxSavedInterruptStatus;

        /* Call taskENTER_CRITICAL_FROM_ISR() to create a critical section, saving the
        returned value into a local stack variable. */
        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();


        /* Execute the code that requires the critical section here. */


        /* Calls to taskENTER_CRITICAL_FROM_ISR() can be nested so it is safe to call a
        function that includes its own calls to taskENTER_CRITICAL_FROM_ISR() and
        taskEXIT_CRITICAL_FROM_ISR(). */
        vDemoFunction();

        /* The operation that required the critical section is complete so exit the
        critical section.  Assuming interrupts were enabled on entry to this ISR, the value
        saved in uxSavedInterruptStatus will result in interrupts being re-enabled.*/
        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
    }
  
  vTaskStartScheduler: Örnek kulanımı aşağıda gösterilmiştir.
    void vTaskStartScheduler( void );
  RTOS scheduler başlatılır. RTOS scheduler çalışmaya başladoktan sonra hangi hangi task'ın çalışacağının ve ne zaman çalışacağının 
  kontrolünü ele almaktadır.
  RTOS scheduler çalışmaya başladığında idle task ve opsiyonel olarak timer daemon task otomatik olarak yaratılır.
  Yalnız eğer idle yada daemon task'ları yaratmak için erişilebilir RTOS heap yetersiz ise vTaskStartScheduler() geri dönecektir.
  Bütün vTaskStartScheduler() kullanımının örneğini içeren RTOS demo uygulama projeleri normalde main.c doyasındaki 
  main() fonksiyonun içerisindedir.
  
  Örnek Kullanımı:
    
     void vAFunction( void )
     {
         // Tasks can be created before or after starting the RTOS scheduler
         xTaskCreate( vTaskCode,
                      "NAME",
                      STACK_SIZE,
                      NULL,
                      tskIDLE_PRIORITY,
                      NULL );

         // Start the real time scheduler.
         vTaskStartScheduler();

         // Will not get here unless there is insufficient RAM.
     }
     
   vTaskEndScheduler: Örnek kullanımı aşağıda gösterilmiştir.
    void vTaskEndScheduler( void );
   Not: Bu yalnızca x86 gerçek mod pc port'ları için kullanılabilmektedir.
   RTOS kernel tick'ini durdurur. Bütün yaratılan task'lar otomatik olarak silinecektir ve 
   multitasking (ya preemptive yada cooperative) duracaktır.
   Çalışma sanki vTaskStartScheduler()'den geri dönülmüş gibi vTaskStartScheduler()'nin çağırıldığı noktadan çalışmaya
   devam eder.
   vTaskEndScheduler() kullanımına bir örnek olması için demo/PC dizinindeki main.c demo uygulama doyasına bakınız.
   vTaskEndScheduler() port edilebilir katman içerisinde tanımlanmak için bir çıkış fonksiyonuna(exit function) ihtiyaç
   duymaktadır( PC port için olan port. c içerisindeki vPortEndScheduler()'e bakınız).
   Bu, RTOS kernel tick'in durdurulması gibi donanıma özel operasyonları yerine getirir.
   vTaskEndScheduler() RTOS kerneli tarafından atanan bütün kaynakların serbest bırakılmasına neden olacaktır - fakat uygulama
   task'lar tarafından atanan kaynakları serbest bırakmayacaktır.
   
   Örnek Kullanım: 
   
   void vTaskCode( void * pvParameters )
   {
       for( ;; )
       {
           // Task code goes here.

           // At some point we want to end the real time kernel processing 
           // so call ...
           vTaskEndScheduler ();
       }
   }

   void vAFunction( void )
   {
       // Create at least one task before starting the RTOS kernel.veril       xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );

       // Start the real time kernel with preemption.
       vTaskStartScheduler();

       // Will only get here when the vTaskCode () task has called 
       // vTaskEndScheduler ().  When we get here we are back to single task 
       // execution.
   }
  
  vTaskSuspendAll: Örnek kullanımı aşağıda gösterilmiştir.
    void vTaskSuspendAll( void );
 Interrupt'ları(kesmeler) etkisizleştirmeksizin scheduler'i askıya almaktadır. Scheduler askıya alınırken context switch'ler 
 oluşmayacaktır. Scheduler askıdayken oluşan RTOS tick'ler scheduler xTaskResumeAll()'i kullanarak askıdan çıkana kadar pending'i
 tutacaktır. 
 Context switch'e sebep olma potansiyeli olan API fonksiyonları(örneğin, vTaskDelayUntil(), xQueueSend(), v.b.) scheduler askıdayken
 çağırılmamalıdır.
 
 Örnek Kullanımı:
  void vTask1( void * pvParameters )
   {
       for( ;; )
       {
           // Task code goes here.

           // ...

           // At some point the task wants to perform a long operation during
           // which it does not want to get swapped out.  It cannot use
           // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
           // operation may cause interrupts to be missed - including the
           // ticks.

           // Prevent the RTOS kernel swapping out the task.
           vTaskSuspendAll ();

           // Perform the operation here.  There is no need to use critical
           // sections as we have all the microcontroller processing time.  
           // During this time interrupts will still operate and the RTOS kernel 
           // tick count will be maintained.

           // ...

           // The operation is complete.  Restart the RTOS kernel.
           xTaskResumeAll ();
       }
   }
 
  xTaskResumeAll: Örnek kullanımı aşağıda gösterilmiştir: 
    BaseType_t xTaskResumeAll( void );
  vTaskSuspendAll() çağırılarak kullanılmasıyla askıya alındıktan sonra scheduler'in çalışmaya devam ettirir.
  
  xTaskResumeAll: Örnek kullanımı aşağıda verilmiştir:
  
    BaseType_t xTaskResumeAll( void );
    
    
  
  
  
  
  
  
