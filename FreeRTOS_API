                                            KONFİGÜRASYON PARAMETRELERİ
Bu parametreler birer macro(define)'dur. Tanım değerine göre FreeRTOS farklı konfigürasyona ayarlanabilmektedir.

configUSE_PREEMPTION -> Eğer 1 olarak tanımlanırsa preemptive RTOS scheduler, 0 olarak tanımlanırsa cooperative RTOS scheduler kullanılacaktır.

configUSE_PORT_OPTIMISED_TASK_SELECTION -> Bazı FreeRTOS portlarının bir sonraki task'ın çalışması için seçebileceği 2 method bulunmaktadır.
Bu methodlar, generic method ve bu porta özel olan methoddur. 
  Generic Method: 
    - configUSE_PORT_OPTIMISED_TASK_SELECTION 0 olarak ayarlandığında, yada bu porta özel method uygulanmadığında kullanılmaktadır.
    - bütün FreeRTOS portları ile kullanılabilmektedir.
    - bütünüyle C dilinde yazılmıştır, bu durum porta özel methoda göre daha az etkin olmasına neden olmaktadır.
    - erişilebilir priority'lerin sayısının belli bir üst limiti aşmamasına zorlamamaktadır.
  Porta özel method:
    - bütün portlar için erişilebilir değildir.
    - configUSE_PORT_OPTIMISED_TASK_SELECTION 1 olarak ayarlandığında kullanılır.
    - bir yada daha fazla mimariye özel assembly instruction'larına bağlıdır (tipik olarak Count Leading Zeros(CLZ) yada eşdeğer instruction)bundan dolayı özel olarak yazıldığı mimariyle birlikte kullanılabilmektedir.
    - generic method'dan daha etkindir.
    - Tipik olarak maksimum erişilebilir priority sayısı 32 ile sınırlı olmaya zorlanmaktadır.
  
 configUSE_TICKLESS_IDLE -> 'low power tickless mode' ile kullanılması için 1 olarak, yada tick interrupt çalışmayı devamlı çalıştırmak için 0 olarak
 ayarlanır.
 
 configUSE_IDLE_HOOK -> idle hook kullanılacaksa 1 olarak, bir idle hook' u ihmal etmek için ise 0 olarak ayarlanmaktadır.
 
 configUSE_MALLOC_FAILED_HOOK -> kernel, her task, queue yada semafor yaratıldığında heap'ten bir hafıza alanını pvPortMalloc() kullanarak tahsis eder.
 Bu amaçla FreeRTOS'un yüklendiğinde içerisinde bulunan 4 temel hafıza tahsis şeması vardır. heap_1.c, heap_2.c, heap_3.c, heap_4.c ve heap_5.c  kaynak dosyalarında uygulanan
 bu şemalar uygulanmaktadır. configUSE_MALLOC_FAILED_HOOK bu üç şema durumuna uygun olarak uygulanmaktadır.
 malloc() hook fonksiyonu uygulamada hata vermektedir ki bu durumda pvPortMalloc() NULL dönmektedir. NULL yalnızca geri kalan FreeRTOS hafızası 
 başarılı bir yer tahsisi için yetersiz kaldığında geri dönüş değeri olmaktadır.
 Eğer configUSE_MALLOC_FAILED_HOOK 1 olarak ayarlanırsa bir malloc() failed fonksiyonu tanımlanmalıdır. Eğer 0 olarak ayarlanmışsa tanımlanmış olsa bile 
 geri dönmez. Malloc() failed fook fonksiyonunun isimi ve prototip tanımı aşağıda gösterilmiştir.
  void vApplicationMallocFailedHook( void );
 
 configUSE_DAEMON_TASK_STARTUP_HOOK -> Eğer configUSE_TIMERS ve configUSE_DAEMON_TASK_STARTUP_HOOK'nun her ikisi de 1 olarak ayarlanmışsa
 aşağıda gösterildiği şekilde bir isme ve prototipe sahip bir hook fonksiyonu tanımlanmalıdır. Hook fonksiyonu RTOS deamon task(timer servis task' da denilmektedir) 
 ilk defa çalıştığında tam olarak 1 kere çağırılmalıdır. RTOS'un çalışması için gereken herhangi bir uygulamanın ilklendirme hook fonksiyonu içerisine yerleştirilebilmektedir.
  void void vApplicationDaemonTaskStartupHook( void );
  
  configUSE_TICK_HOOK -> 'tick hook'u kullanmak istiyorsak 1 olarak, istemiyorsak 0 olarak ayarlamamız gerekmektedir.
  
  configCPU_CLOCK_HZ -> çevresel birimin kullanması için sürülen dahili(internal) clock'un girilir ki bu değeri genelde dahili CPU clock 
  üretmektedir. Bu değer timer'ları düzgün bir şekilde konfigüre etmek için gerekmektedir.
  
  configTICK_RATE_HZ -> RTOS tick interrupt'ın frekansıdır. 
  tick interrupt zamanı ölçmek için kullanılmaktadır. Bundan dolayı daha yüksek tick frekansına sahip olmak zamanın daha yüksek bir
  çözünürlükle ölçülebilmesini sağlamaktadır.
  
  configMAX_PRIORITIES -> Uygulama task'ı için erişilebilir priority'lerin sayısıdır. Herhangi bir sayıdaki task aynı priority'yi paylaşabilmektedir.
  Coroutine'ler ayrıca önceliklendirileceklerdir (prioritised) - configMAX_CO_ROUTINE_PRIORITIES'i inceleyiniz.
  Herbir erişilebilir priority, RTOS kernel'i içerisindeki RAM'i tüketmektedir ki bundan dolayı sizin uygulamanız tarafından gerçekte istenenden 
  daha yüksek olmamalıdır.
  
  configMINIMAL_STACK_SIZE -> Idle task tarafından kullanılan stack'in boyutudur. Genelde kullanmakta olduğunuz port için olan demo ı-uygulaması 
  ile gelen FreeRTOSConfig.h'im içerisindeki değerden elde edilmemelidir.
  xTaskCreate() ve xTaskCreateStatic() fonksiyonları için olan stack size parametrelerinde olduğu gibi, stack size word cinsinden 
  belirtilmektedir, byte cinsinden değil.
  Stack'teki her bir item 32 bit değerlikli ise, stack size'ın 100 olması 400 byte'lık bir alanı temsil etmektedir (her bir 32 bit'lik stack itemi 4 byte'ı temsil etmektedir).
  
  configMAX_TASK_NAME_LEN -> Task yaratılırken tanımlatıcı ismin müsade edilebilir maksimum uzunluğunu temsil etmektedir. NULL termination byte'ı da içerecek
  şekilde toplam karakter sayısının değeridir.
  
  configUSE_TRACE_FACILITY -> Eğer visualisation ve tracing çalışması ile ek structure member'ların ve fonksiyonların da dahil olması
  isteniyorsa 1 olarak ayarlanmalıdır.
  
  configUSE_STATS_FORMATTING_FUNCTIONS -> Build esnasında vTaskList() ve vTaskGetRunTimeStats() fonksiyonlarının da dahil olması 
  isteniyorsa configUSE_TRACE_FACILITY ve configUSE_STATS_FORMATTING_FUNCTIONS 1 olarak ayarlanmalıdır. Build esnasında ihmal etmek için ise
  0 olarak ayarlanmalıdır.
  
  configUSE_16_BIT_TICKS -> Zaman, RTOS kerneli çalışmaya başladığından beri tick interrupt'ının meydana gelme sayısını temsil eden 'ticks' 
  ile ölçülmektedir.
  configUSE_16_BIT_TICKS'nin 1 olarak ayarlanması TickType_t'nin 16 bit olarak tanımlanmasına, 0 ayarlanması 32 bit olarak tanımlanmasına 
  neden olmaktadır.
  16 bit tip kullanılması 8 bit ve 16 bit mimari için performansı arttırmaktadır fakat zaman periyodunu 65535 tick ile sınırlamaktadır. Bu durumda örneğin
  250 Hz tick frekansı için maksimum gecikme süresi 262 saniyedir fakat 32 bit tip sayıcı kullanılsa 17179869 saniye gecikme verilebilir.
  
  configIDLE_SHOULD_YIELD -> Bu parametre idle priority için task'ların davranışını kontrol eder. Yalnızca etki ettiği durum:
    1- Preemptive scheduler kullanıldığında.
    2- Uygulama idle priority'de çalışan task'lar yarattığında.
  Eğer configUSE_TIME_SLICING 1 olarak ayarlanırsa(yada tanımsızsa) aynı priority'yi paylaşan task'lar zamanı dilimleyeceklerdir. Eğer 
  hiç bir task preempt edilmemişse verilen priority'deki her bir task zamanı eşit zaman diliminde çalışırlar - bu durum gerçekte idle priority'nin
  üstündeki değer için geçerlidir.
  Eğer task'lar idle priority değerinde ise davranışları değişmektedir. Eğer configIDLE_SHOULD_YIELD 1 olaraak set edilmişse idle task başka 
  idle prioty'li task ayarlanmış olsa da hemen çalışır. Bu durum idle task çalıştığı esnada çalışan idle priority'li task'ın diğer diğer idle priority'li
  task'lardan daha az süre almasına sebep olur.
  Bunu engellemek için aşağıdakiler uygulanabilir:
    1- Eğer uygunsa, idle priority' deki ayrı tasklar yerine idle hook kullanılır
    2- Bütün oluşturulan task'lar idle priority'den daha yüksek öncelikli oluşturulur
    3- configIDLE_SHOULD_YIELD 0 olarak ayarlanır.
  configIDLE_SHOULD_YIELD'nin 0 olarak ayarlanması zaman diliminin sonuna kadar idle taskın processing time'ı harcamasına engel olmaktadır.
  Bu durum bütün idle priority'deki task'ların eşit processing time'ı almasını fakat toplamda idle task'ın daha yüksek oranda processing time
  maliyetine sahip olmasına neden olmaktadır.
  
  configUSE_TASK_NOTIFICATIONS -> configUSE_TASK_NOTIFICATIONS'nin 1 olarak ayarlanması (yada tanımsız olarak bırakılması) 'direct to task notification' 
  fonksiyonalitesine ve derleme içinde API'nin ilişkilendirilmesini içermektedir. Eğer  0 olarak ayarlanırsa yukarıdaki durumlar kapsam dışına çıkmaktadır.
  'direct to task notification'nin build içerisindeki dahili olma maliyeti her bir task başına 8 ekstra byte'dır.
  
  configUSE_MUTEXES -> 1 olarak ayarlanması build esnasında mutex'in dahil edilmesine sebep olmaktadır. 
  
  configUSE_RECURSIVE_MUTEXES -> 1 olarak ayarlanması build esnasında recursive mutex'in dahil edilmesine sebep olmaktadır. 
  
  configUSE_COUNTING_SEMAPHORES -> 1 olarak ayarlanması build esnasında counting semaphore'un dahil edilmesine sebep olmaktadır. 
  
  configUSE_ALTERNATIVE_API -> 1 olarak ayarlanması build esnasında 'alternative' queue function'ın dahil edilmesine sebep olmaktadır. 
  alternative API yeni tasarımlarda kullanılmaktadır.
  
  configCHECK_FOR_STACK_OVERFLOW -> stack overflow detection sayfası bu parametrenin kullanımını tanımlamaktadır.
  
  configQUEUE_REGISTRY_SIZE -> Queue registry'nin 2 amacı vardır, her ikisi de RTOS kernel farkındalıklı debuggin'dir: 
    1- GUI debugging içerisindeki kolay queue tanımlaması için olan queue ile alakalı metinsel isime izin verir.
    2- Her bir registered queue ve semafor için yerleşmeyi amaçlayan debugger tarafından ihtiyaç duyulan bilgiyi içerir.
  RTOS kernel farkındaliklı debugger'ı kulllanmadıkça queue register'ın bir amacı yoktur.
  configQUEUE_REGISTRY_SIZE register edilebilen maksimum sayıdaki queue ve semafor'u tanımlamaktadır.
  Yalnızca RTOS kernel farkındalıklı debugger kullanarak bu görmek istedğiniz queueu'lar ve semafor'ların kaydedilmeye(registered) ihtiyaç duyulur.
  vQueueAddToRegistry() ve vQueueUnregisterQueue() hakkında daha fazla bilgi için API referans dokümanına bakınız.
  
  configUSE_QUEUE_SETS -> queue set fonksiyonalitesi içermesi için (çoklu queue ve semafor üzerindeki block, yada pend imkanı için) 1 olarak 
  ayarlanmaktadır.
  
  configUSE_TIME_SLICING -> Varsayılanda 
  
